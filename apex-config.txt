eres un analista desarrollador senior con muchos a√±os de experiencia desarrollando sistemas en oracle apex, cuentas con multiples certificaciones en oracle apex 24.2.8, necesito que dise√±es el siguiente requerimiento en mi aplicaci√≥n en apex: implementar un proceso que sea ejecutado 2 segundos antes que la sesi√≥n del usuario finalice, en dos escenarios: fin de sesi√≥n por inactividad o fin de sesi√≥n por expiraci√≥n de tiempo maximo, para ello es necesario crear un watchdog o temporizador que se ejecute al momento de iniciar sesi√≥n, y este escuchando a los eventos del usuario, para saber si est√° inactivo y especificamente la acci√≥n de extender la sesi√≥n integrada en oracle apex, en el caso de hacer clic en boton Extend del confirm, debe tomarse en cuenta y recalcular los tiempos para ejecutar el proceso de finalizar sesi√≥n, los parametros solamente para validar la funcionalidad ser√°n: Maximum Session Length Seconds (240), Maximum Session Idle Time in Seconds (60) y Session Timeout Warning in Senconds (30) y  deden leerse al iniciar una nueva sesi√≥n de la configuraci√≥n de la aplicaci√≥n y almacenarse en un item de session, el proceso solamente debe ejecutarse una unica vez 2 segundos antes de vencer la sesi√≥n, no se tienen que duplicar ejecuciones creando falsos positivos, la unica manera es que se pueda duplicar es que en esos dos segundos antes de que apex finalice la sesi√≥n el usuario extienda la misma, el proceso simplemente ejecutar√° un procedimiento almacenado que notifique el fin de sesi√≥n, esa implementaci√≥n (el procedimiento) me encargo yo, pero crea todo el flujo e indica paso a paso que debo hacer, donde y como, dado a que soy totalmente nuevo en oracle apex.

// --- Variables de Configuraci√≥n ---
var MAX_SESSION_LENGTH = 240; 
var MAX_SESSION_IDLE = 60;   
var WARNING_TIME = 30;       

// --- Variables del Watchdog ---
const WATCHDOG_INTERVAL = 1000; 
let watchdogTimer;
let sessionStartTime;           
let lastActivityTime;           
let isProcessExecuted = false;

// Obtener el ID de Sesi√≥n actual de APEX
const CURRENT_SESSION_ID = apex.view.sessionStorage.getItem('APEX_SESSION_ID');


// --- Funciones del Watchdog ---

function getNearestExpiryTimestamp() {
    const lengthExpiryTimestamp = sessionStartTime + (MAX_SESSION_LENGTH * 1000);
    const idleExpiryTimestamp = lastActivityTime + (MAX_SESSION_IDLE * 1000);
    return Math.min(lengthExpiryTimestamp, idleExpiryTimestamp);
}

function sessionWatchdog() {
    // **VALIDACI√ìN CR√çTICA (1):** Detener si el proceso ya se ejecut√≥ o si la sesi√≥n de APEX ya no existe.
    if (isProcessExecuted || !CURRENT_SESSION_ID || !apex.session.getCurrent()) {
        clearInterval(watchdogTimer);
        console.log('‚õî Watchdog detenido: Sesi√≥n expirada/finalizada o proceso ya ejecutado.');
        return;
    }

    const nearestExpiryTimestamp = getNearestExpiryTimestamp();
    const currentTime = Date.now();
    const timeUntilExpiry = nearestExpiryTimestamp - currentTime;
    const TWO_SECONDS_MS = 2000;

    // L√≥gica de Ejecuci√≥n √önica: Si estamos dentro de los √∫ltimos 2 segundos
    if (timeUntilExpiry > 0 && timeUntilExpiry <= TWO_SECONDS_MS) {
        
        if (!isProcessExecuted) {
            console.warn(`‚è≥ Ejecutando proceso finalizaci√≥n. Tiempo restante: ${timeUntilExpiry / 1000}s`);

            // Ejecuta la llamada AJAX al proceso On-Demand
            apex.server.process("FINALIZE_SESSION_PROCESS", {}, {
                dataType: 'json',
                success: function(pData) {
                    if (pData.success) {
                        isProcessExecuted = true;
                        clearInterval(watchdogTimer); 
                        console.log('‚úÖ Proceso de finalizaci√≥n ejecutado con √©xito. Temporizador detenido.');
                    }
                },
                error: function(jqXHR, textStatus, errorThrown) {
                    console.error('‚ùå Error al ejecutar el proceso de finalizaci√≥n:', errorThrown);
                    // Si falla, no detenemos el timer, se reintentar√° en el siguiente ciclo.
                }
            });
        }
    }
}

function recordUserActivity() {
    lastActivityTime = Date.now();
    // Reinicia la bandera y el timer solo si la sesi√≥n es v√°lida
    if (apex.session.getCurrent() && isProcessExecuted) {
         isProcessExecuted = false;
         if (!watchdogTimer) {
             watchdogTimer = setInterval(sessionWatchdog, WATCHDOG_INTERVAL);
         }
    }
}

function handleSessionExtend(pEvent, pData) {
    if (pData && pData.extended) {
        console.info('üöÄ Sesi√≥n Extendida. Recalculando Watchdog.');
        sessionStartTime = Date.now();
        lastActivityTime = Date.now(); 
        isProcessExecuted = false; 

        if (!watchdogTimer) {
             watchdogTimer = setInterval(sessionWatchdog, WATCHDOG_INTERVAL);
        }
    }
}

// **********************************************
// INICIALIZACI√ìN AL CARGAR LA P√ÅGINA
// **********************************************

// **VALIDACI√ìN CR√çTICA (2):** No iniciar el watchdog si no hay sesi√≥n v√°lida.
if (CURRENT_SESSION_ID && apex.session.getCurrent()) {
    const sessionStartTimeDB = apex.item('G_SESSION_START_TIME').getValue();
    
    if (sessionStartTimeDB) {
        // Conversi√≥n de Segundos (DB) a Milisegundos (JS)
        sessionStartTime = sessionStartTimeDB * 1000; 
        lastActivityTime = Date.now(); 

        // Inicia el Watchdog
        watchdogTimer = setInterval(sessionWatchdog, WATCHDOG_INTERVAL);

        // Suscripciones a eventos
        $(document).on('apexextendedsession', handleSessionExtend);
        $(document).on('mousemove keydown click', recordUserActivity);
        
        console.log('‚úÖ Watchdog de Sesi√≥n Inicializado y en escucha.');
    } else {
        console.error('‚ùå G_SESSION_START_TIME no disponible. Revise el proceso After Authentication.');
    }
} else {
    console.log('‚ö†Ô∏è Watchdog no iniciado: Usuario no autenticado o sesi√≥n no inicializada.');
}

















---------------------------------------------------------------------------------------------------------


Te ayudo a dise√±ar esta soluci√≥n paso a paso. Implementaremos un sistema que monitoree la sesi√≥n del usuario y ejecute un proceso 2 segundos antes de que finalice.

üìã Arquitectura de la Soluci√≥n
Paso 1: Crear Items de P√°gina para Almacenar Configuraci√≥n
Ve a Shared Components > Application Items y crea:

APP_SESSION_MAX_LENGTH - Duraci√≥n m√°xima de sesi√≥n

APP_SESSION_IDLE_TIME - Tiempo m√°ximo de inactividad

APP_SESSION_WARNING_TIME - Tiempo de advertencia

APP_SESSION_LAST_ACTIVITY - √öltima actividad del usuario

APP_SESSION_WATCHDOG_ACTIVE - Estado del watchdog

Paso 2: Crear Proceso de Inicializaci√≥n
En la p√°gina de inicio (normalmente p√°gina 1), ve a Procesos > Crear Proceso:

Proceso: INIT_SESSION_CONFIG

Tipo: PL/SQL

Punto: After Header

sql
BEGIN
    -- Obtener configuraci√≥n de la aplicaci√≥n
    :APP_SESSION_MAX_LENGTH := 240;  -- 4 minutos
    :APP_SESSION_IDLE_TIME := 60;    -- 1 minuto
    :APP_SESSION_WARNING_TIME := 30; -- 30 segundos
    :APP_SESSION_LAST_ACTIVITY := SYSDATE;
    :APP_SESSION_WATCHDOG_ACTIVE := 'Y';
END;
Paso 3: Crear Procedimiento Almacenado
En SQL Workshop > SQL Commands, ejecuta:

sql
CREATE OR REPLACE PROCEDURE session_ending_notification (
    p_user IN VARCHAR2,
    p_session_id IN NUMBER,
    p_reason IN VARCHAR2
) AS
BEGIN
    -- Este procedimiento lo implementar√°s t√∫
    -- Aqu√≠ va tu l√≥gica de notificaci√≥n
    INSERT INTO session_log (user_name, session_id, end_reason, end_time)
    VALUES (p_user, p_session_id, p_reason, SYSDATE);
    
    COMMIT;
END session_ending_notification;
/
Paso 4: Crear Funci√≥n para Calcular Tiempo Restante
En Application > Shared Components > Application Processes:

Proceso: CALCULATE_SESSION_TIMEOUT

Tipo: PL/SQL

Punto: On Demand

sql
DECLARE
    l_max_session_length NUMBER := :APP_SESSION_MAX_LENGTH;
    l_max_idle_time      NUMBER := :APP_SESSION_IDLE_TIME;
    l_session_start      DATE;
    l_last_activity      DATE := :APP_SESSION_LAST_ACTIVITY;
    l_current_time       DATE := SYSDATE;
    l_time_until_max     NUMBER;
    l_time_until_idle    NUMBER;
    l_time_until_end     NUMBER;
BEGIN
    -- Calcular tiempo hasta expiraci√≥n por m√°xima duraci√≥n
    l_session_start := v('APP_SESSION_START_TIME');
    l_time_until_max := l_max_session_length - ((l_current_time - l_session_start) * 24 * 60 * 60);
    
    -- Calcular tiempo hasta expiraci√≥n por inactividad
    l_time_until_idle := l_max_idle_time - ((l_current_time - l_last_activity) * 24 * 60 * 60);
    
    -- Tomar el menor tiempo
    l_time_until_end := LEAST(l_time_until_max, l_time_until_idle);
    
    -- Restar 2 segundos para ejecutar antes
    l_time_until_end := l_time_until_end - 2;
    
    -- Asegurar que sea positivo
    IF l_time_until_end < 1 THEN
        l_time_until_end := 1;
    END IF;
    
    -- Retornar tiempo en milisegundos para JavaScript
    RETURN TO_CHAR(l_time_until_end * 1000);
EXCEPTION
    WHEN OTHERS THEN
        RETURN '5000'; -- Valor por defecto
END;
Paso 5: Implementar el Watchdog en JavaScript
En la p√°gina de inicio, ve a Page Attributes > JavaScript > Function and Global Variable Declaration:

javascript
var sessionWatchdog = null;
var sessionExtended = false;

function startSessionWatchdog() {
    // Detener watchdog existente
    if (sessionWatchdog) {
        clearTimeout(sessionWatchdog);
    }
    
    // Obtener tiempo para ejecutar proceso
    apex.server.process("CALCULATE_SESSION_TIMEOUT", {}, {
        success: function(pData) {
            var timeUntilExecution = parseInt(pData);
            
            if (timeUntilExecution > 0) {
                sessionWatchdog = setTimeout(function() {
                    executeSessionEndProcess();
                }, timeUntilExecution);
            }
        }
    });
}

function executeSessionEndProcess() {
    // Verificar si la sesi√≥n fue extendida
    if (!sessionExtended) {
        // Ejecutar proceso de fin de sesi√≥n
        apex.server.process("SESSION_ENDING_PROCESS", {
            x01: 'SESSION_END'
        }, {
            success: function() {
                console.log('Session end process executed');
            },
            error: function() {
                console.log('Error executing session end process');
            }
        });
    } else {
        // Resetear flag y reiniciar watchdog
        sessionExtended = false;
        startSessionWatchdog();
    }
}

function extendSession() {
    sessionExtended = true;
    
    // Actualizar √∫ltima actividad
    apex.server.process("UPDATE_LAST_ACTIVITY", {}, {
        success: function() {
            // Reiniciar watchdog con nuevos tiempos
            startSessionWatchdog();
        }
    });
}
Paso 6: Crear Proceso para Actualizar Actividad
En Application > Shared Components > Application Processes:

Proceso: UPDATE_LAST_ACTIVITY

Tipo: PL/SQL

Punto: On Demand

sql
BEGIN
    :APP_SESSION_LAST_ACTIVITY := SYSDATE;
END;
Paso 7: Crear Proceso de Fin de Sesi√≥n
En Application > Shared Components > Application Processes:

Proceso: SESSION_ENDING_PROCESS

Tipo: PL/SQL

Punto: On Demand

sql
DECLARE
    l_reason VARCHAR2(100);
BEGIN
    -- Determinar raz√≥n del fin de sesi√≥n
    IF (:APP_SESSION_LAST_ACTIVITY + (:APP_SESSION_IDLE_TIME / 86400)) < SYSDATE THEN
        l_reason := 'INACTIVITY';
    ELSE
        l_reason := 'MAX_LENGTH_EXPIRED';
    END IF;
    
    -- Ejecutar tu procedimiento
    session_ending_notification(
        p_user => :APP_USER,
        p_session_id => :APP_SESSION,
        p_reason => l_reason
    );
    
    -- Marcar watchdog como inactivo
    :APP_SESSION_WATCHDOG_ACTIVE := 'N';
END;
Paso 8: Configurar Event Listeners
En Page Attributes > JavaScript > Execute when Page Loads:

javascript
// Iniciar watchdog cuando carga la p√°gina
$(document).ready(function() {
    startSessionWatchdog();
});

// Monitorear actividad del usuario
$(document).on('click keypress scroll mousemove', function() {
    apex.server.process("UPDATE_LAST_ACTIVITY", {});
});

// Capturar evento de extender sesi√≥n (cuando APEX muestra el di√°logo de timeout)
$(document).on('apexbeforeexpire', function() {
    // Este evento se dispara antes de que APEX expire la sesi√≥n
    extendSession();
});

// Manejar el bot√≥n "Extend" del di√°logo de APEX
$(document).on('dialogclose', function(event, ui) {
    var $dialog = $(event.target);
    if ($dialog.attr('id') && $dialog.attr('id').indexOf('apex_session_timeout') !== -1) {
        extendSession();
    }
});
Paso 9: Configurar Timeout de Aplicaci√≥n
En Application Properties > Security > Session Management:

Maximum Session Length: 240 seconds

Maximum Session Idle Time: 60 seconds

Session Timeout Warning: 30 seconds

Paso 10: Proceso de Limpieza al Cerrar Sesi√≥n
Crea un proceso de aplicaci√≥n en Shared Components > Application Processes:

Proceso: CLEANUP_ON_LOGOUT

Tipo: PL/SQL

Punto: On Logout

sql
BEGIN
    -- Ejecutar notificaci√≥n de logout manual
    IF :APP_SESSION_WATCHDOG_ACTIVE = 'Y' THEN
        session_ending_notification(
            p_user => :APP_USER,
            p_session_id => :APP_SESSION,
            p_reason => 'MANUAL_LOGOUT'
        );
    END IF;
END;
üîß Resumen de Implementaci√≥n
Items de Aplicaci√≥n: Para almacenar configuraci√≥n y estado

Procesos de Aplicaci√≥n: Para l√≥gica server-side

JavaScript Client-side: Para monitoreo en tiempo real

Event Listeners: Para capturar actividad y extensi√≥n de sesi√≥n

Procedimiento Almacenado: Para tu l√≥gica espec√≠fica

‚ö†Ô∏è Consideraciones Importantes
Evitar duplicados: El flag sessionExtended previene ejecuciones duplicadas

Sincronizaci√≥n: Los tiempos se recalculan despu√©s de extender sesi√≥n

Performance: El monitoreo es eficiente usando eventos nativos del DOM

Compatibilidad: Funciona con el sistema de timeout nativo de APEX

¬øNecesitas que ajuste alguna parte espec√≠fica de la implementaci√≥n?









----------------------------------------------------------------------

Perfecto ‚Äî te doy un dise√±o paso a paso, listo para implementar en Oracle APEX 24.x para cumplir exactamente tu requerimiento: ejecutar 1 √∫nica vez (salvo que el usuario extienda la sesi√≥n dentro de esos 2 segundos) un proceso 2 segundos antes de que la sesi√≥n finalice, ya sea por idle o por maximum session length. Incluyo: d√≥nde crear items/procesos, PL/SQL y JavaScript listos para pegar, explicaci√≥n de por qu√© funciona y referencias a la doc oficial y foros (para que tengas soporte t√©cnico). Voy directo al grano.

Fuentes clave (para referencia / comprobaci√≥n): documentaci√≥n APEX sobre Application Processes (On New Instance), configuraci√≥n de Session Timeout y API utilitarias; y un hilo de foro que documenta comportamiento del bot√≥n Extend/problemas cuando se hace clic muy cerca del timeout. 
Oracle Forums
+3
Oracle Docs
+3
Oracle Docs
+3

Resumen de la soluci√≥n (visi√≥n r√°pida)

Al iniciar sesi√≥n se leen (o inicializan) los 3 par√°metros de timeout y se guardan en items de sesi√≥n (Page 0 / Application Items).

En Page 0 (global) se inyecta un watchdog JavaScript que:

escucha actividad del usuario (mouse/teclado/touch/click),

escucha la extensi√≥n de sesi√≥n (interceptando la llamada ORDS que APEX usa para "extend"),

calcula el instante exacto de expiraci√≥n (considerando max length y idle),

programa un setTimeout para ejecutar 2 segundos antes del vencimiento,

asegura ejecuci√≥n √∫nica (solo se dispara una vez por ciclo de sesi√≥n; si el usuario extiende dentro de los 2 segundos, el watchdog se recalcula y puede disparar otra vez en la nueva ventana).

Cuando el timer dispara, el JS invoca un Application Process On Demand (NOTIFY_SESSION_END) que ejecuta el procedimiento almacenado que t√∫ vas a implementar (el proceso PL/SQL pasar√° la info necesaria: session id, usuario, motivo, timestamp).

Todo el flujo es robusto a m√∫ltiples pesta√±as / re-render y evita duplicados mediante banderas en memoria y verificaci√≥n del tiempo restante antes de invocar el proceso.

1) Preparar la aplicaci√≥n (Shared Components)

Configura los valores de la aplicaci√≥n (para las pruebas que pediste):

Ve a Shared Components ‚Üí Security ‚Üí Session Management y aseg√∫rate de poner:

Maximum Session Length in Seconds = 240

Maximum Session Idle Time in Seconds = 60

Session Timeout Warning in Seconds = 30

(Eso es lo que usar√°s para validar la funcionalidad). La documentaci√≥n APEX confirma estos atributos en Session Timeout de la app. 
Oracle Docs

Crea Application Items (Page 0 / Application Items) ‚Äî para mantener en session state:

P0_MAX_SESSION_LEN (n√∫mero)

P0_MAX_SESSION_IDLE (n√∫mero)

P0_SESSION_WARN (n√∫mero)

P0_SESSION_EXPIRY_TS (text / timestamp ISO) ‚Äî opcional para debug/inspecci√≥n

P0_LAST_ACTIVITY_TS (text / timestamp ISO) ‚Äî opcional

P0_NOTIFY_REASON (text) ‚Äî opcional, si quieres pasar motivo al SP

(Crear items en Shared Components ‚Üí Application Items o en Page 0 como Page Items siempre visibles).

Application Process ‚Äì On New Instance (se ejecuta al crear la sesi√≥n)

Crea un Application Process con Process Point = On New Instance (esto garantiza que se ejecute una vez al inicio de la sesi√≥n). La doc describe que On New Instance es para inicializar valores por sesi√≥n. 
Oracle Docs

C√≥digo PL/SQL de ejemplo (c√≥pialo al proceso On New Instance). Este proceso lee los par√°metros de la app (si prefieres) o establece los valores fijos para las pruebas:

-- Shared Components -> Application Processes -> New -> Process Point = On New Instance
DECLARE
  v_max_len   NUMBER := 240;  -- para pruebas; puedes sustituir por lectura de metadata
  v_max_idle  NUMBER := 60;
  v_warn_sec  NUMBER := 30;
BEGIN
  -- Guardar en items de sesi√≥n (Page 0)
  :P0_MAX_SESSION_LEN  := v_max_len;
  :P0_MAX_SESSION_IDLE := v_max_idle;
  :P0_SESSION_WARN     := v_warn_sec;

  -- opcional: inicializar timestamps
  :P0_LAST_ACTIVITY_TS := TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD"T"HH24:MI:SS.FF TZH:TZM');
  :P0_SESSION_EXPIRY_TS := NULL;
END;


Nota: si prefieres leer los valores program√°ticamente desde la metadata de APEX, puedes consultar las APEX views (Utilities ‚Üí APEX Views) y hacer SELECT ... FROM APEX_APPLICATIONS WHERE APPLICATION_ID = :APP_ID para localizar las columnas exactas en tu versi√≥n; para pruebas lo m√°s simple es setear los valores aqu√≠ (la idea es la misma). La gu√≠a de APEX explica el punto On New Instance para inicializar valores por sesi√≥n. 
Oracle Docs
+1

2) Crear el Application Process "NOTIFY_SESSION_END" (On Demand)

Vas a necesitar un Application Process que el browser invoque cuando falten 2 segundos. Lo definimos On Demand (ser√° llamado por AJAX desde JS).

Crear: Shared Components ‚Üí Application Processes ‚Üí New

Name: NOTIFY_SESSION_END

Type: PL/SQL (On Demand) ‚Äî Point: On Demand

C√≥digo (ejemplo stub ‚Äî aqu√≠ llamas a tu procedimiento):

-- Application Process: NOTIFY_SESSION_END (On Demand)
DECLARE
  l_reason VARCHAR2(200) := apex_application.g_x01; -- JS puede pasar x01 con motivo
  l_session_id NUMBER := TO_NUMBER(:APP_SESSION);
  l_user VARCHAR2(100) := :APP_USER;
BEGIN
  -- Llamar al procedimiento almacenado tuyo (t√∫ lo implementas)
  -- EJEMPLO: my_schema.notify_session_end(p_session_id => l_session_id, p_user => l_user, p_reason => l_reason);
  NULL; -- reemplaza con la llamada real

  -- opcional: devolver dato JSON
  htp.p('{"status":"ok"}');
END;


Seguridad: establece Authorization Scheme apropiado (por ejemplo Is Authenticated) para que s√≥lo usuarios v√°lidos lo invoquen.

La doc APEX describe On Demand Application Processes y c√≥mo invocarlos desde JS (apex.server.process) o por f?p=...&APPLICATION_PROCESS=.... 
Oracle Docs

3) Page 0 ‚Äî JavaScript watchdog global

A√±ade un Dynamic Action en Page 0 (ejecutado en Page Load) que ejecute JavaScript (o agrega ese JS en el Global Page > Execute when Page Loads). Pega exactamente este JS (explicado despu√©s):

Este JavaScript:

calcula expiraci√≥n por max length y por idle,

programa la ejecuci√≥n 2 segundos antes,

evita dobles ejecuciones con una bandera,

resetea el timer en cualquier actividad del usuario,

detecta la acci√≥n de extend session interceptando la llamada ORDS que APEX usa (/ords/apex_session.emit_timeouts?...p_reset_idle=Y) ‚Äî cuando detecta la llamada de extensi√≥n reinicia el conteo.

C√≥digo JS (Page 0 ‚Üí Execute when Page Loads):

(function(){
  // helpers
  function nowMs(){ return (new Date()).getTime(); }
  function iso(ts){ return new Date(ts).toISOString(); }

  // read values (Page 0 items)
  var maxLenSec = Number($v('P0_MAX_SESSION_LEN') || 240);
  var maxIdleSec = Number($v('P0_MAX_SESSION_IDLE') || 60);
  var warnSec =   Number($v('P0_SESSION_WARN') || 30);

  // state
  var sessionStartMs = nowMs();
  var lastActivityMs = nowMs();
  var expiryMs = null;
  var watchdogTimer = null;
  var watchdogFired = false; // evita duplicados
  var lock = false;

  // calcula el pr√≥ximo expiry (min entre life y idle)
  function computeExpiryMs(){
    var byLife = sessionStartMs + (maxLenSec * 1000);
    var byIdle = lastActivityMs + (maxIdleSec * 1000);
    return Math.min(byLife, byIdle);
  }

  function scheduleWatchdog(){
    if(watchdogTimer){
      clearTimeout(watchdogTimer);
      watchdogTimer = null;
    }
    expiryMs = computeExpiryMs();
    // queremos ejecutar 2s antes que expiry
    var fireAt = expiryMs - 2000;
    var delay = fireAt - nowMs();

    // si ya se dispar√≥, no reprogramar, salvo que la sesi√≥n se haya extendido
    if(watchdogFired){
      // si la nueva ventana vuelve a ser > 2s en el futuro, reinicia la bandera para permitir nueva ejecuci√≥n
      if(delay > 2000){
        watchdogFired = false;
      } else {
        // no hay ventana, no reprogramamos
        return;
      }
    }

    if(delay <= 0){
      // estamos dentro de la ventana (menos de 2s): ejecuta ahora (debemos comprobar si no se extendi√≥ ya)
      setTimeout(onWatchdogFire, 0);
    } else {
      watchdogTimer = setTimeout(onWatchdogFire, delay);
      console.debug('Watchdog programado para:', iso(fireAt), 'en ms:', delay);
    }

    // opcional: guarda para debug en item de sesi√≥n (no se env√≠a al servidor)
    try{
      $s('P0_SESSION_EXPIRY_TS', iso(expiryMs));
      $s('P0_LAST_ACTIVITY_TS', iso(lastActivityMs));
    }catch(e){}
  }

  function onWatchdogFire(){
    if(watchdogFired) return; // protecci√≥n doble
    watchdogFired = true;

    // antes de notificar, valida que falta (aprox) <= 2s para expiraci√≥n real
    var rem = expiryMs - nowMs();
    if(rem > 3000){
      // race: parece que tenemos m√°s tiempo del esperado -> re-agendar
      watchdogFired = false;
      scheduleWatchdog();
      return;
    }

    // Llamar al Application Process On Demand NOTIFY_SESSION_END
    try{
      apex.server.process(
        'NOTIFY_SESSION_END',
        { x01: 'session_will_end' }, // x01 ser√° le√≠do por el PL/SQL si quieres
        {
          dataType: 'json',
          success: function(pData){
            console.info('NOTIFY_SESSION_END OK', pData);
          },
          error: function(pErr){
            console.warn('NOTIFY_SESSION_END ERROR', pErr);
          }
        }
      );
    }catch(e){
      console.error('Error al invocar NOTIFY_SESSION_END', e);
    }
  }

  // eventos de usuario que deben resetear lastActivity
  function onUserActivity(){
    lastActivityMs = nowMs();
    // si ya se dispar√≥ y el usuario extendi√≥ (o hubo actividad) dentro de la ventana,
    // permitimos nuevas ejecuciones reiniciando watchdogFired en caso que haya suficiente tiempo
    scheduleWatchdog();
  }

  // attach listeners
  ['mousemove','keydown','click','touchstart'].forEach(function(ev){
    window.addEventListener(ev, onUserActivity, { passive:true });
  });

  // Interceptar XHR/Fetch que APEX/ORDS usa para "extend session"
  // Observaci√≥n: APEX hace requests a /ords/apex_session.emit_timeouts?p_reset_idle=Y cuando se hace Extend.
  // Si detectamos esa llamada, la consideramos "extend" y reajustamos timers.
  (function(){
    // wrap XHR.open to detect URL
    var origOpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function(method, url){
      try{
        if(url && url.indexOf('/ords/apex_session.emit_timeouts') !== -1){
          // el request ser√° enviado; observamos el query param p_reset_idle
          if(url.indexOf('p_reset_idle=Y') !== -1){
            // sesi√≥n se extendi√≥; actualizar lastActivity y reprogramar
            console.debug('Detected ORDS extend (XHR) -> reset activity');
            lastActivityMs = nowMs();
            // permitir nuevas ejecuciones en el futuro
            watchdogFired = false;
            // reprogramar watchdog
            setTimeout(scheduleWatchdog, 50);
          }
        }
      }catch(e){}
      return origOpen.apply(this, arguments);
    };

    // Tambi√©n wrap fetch (por si APEX usa fetch)
    if(window.fetch){
      var origFetch = window.fetch;
      window.fetch = function(resource, init){
        try{
          var url = (typeof resource === 'string') ? resource : (resource && resource.url);
          if(url && url.indexOf('/ords/apex_session.emit_timeouts') !== -1 && url.indexOf('p_reset_idle=Y') !== -1){
            console.debug('Detected ORDS extend (fetch) -> reset activity');
            lastActivityMs = nowMs();
            watchdogFired = false;
            setTimeout(scheduleWatchdog, 50);
          }
        }catch(e){}
        return origFetch.apply(this, arguments);
      };
    }
  }());

  // kick off
  scheduleWatchdog();

  // expose for debug in console
  window.__apexWatchdog = {
    scheduleWatchdog: scheduleWatchdog,
    computeExpiryMs: computeExpiryMs,
    getState: function(){ return {sessionStartMs, lastActivityMs, expiryMs, watchdogFired}; }
  };

})();


Explicaci√≥n t√©cnica r√°pida del JS:

sessionStartMs = momento en que el script se carga (aprox inicio de sesi√≥n en la primera carga despu√©s de autenticaci√≥n).

lastActivityMs se actualiza con cualquier interacci√≥n.

expiryMs = min(sessionStart + maxLen, lastActivity + maxIdle).

scheduleWatchdog() programa ejecuci√≥n exactamente 2 segundos antes (expiryMs - 2000).

onWatchdogFire() verifica que realmente no hubo extensi√≥n de sesi√≥n y luego llama apex.server.process('NOTIFY_SESSION_END').

Para detectar el Extend integrado de APEX se interceptan las llamadas hacia /ords/apex_session.emit_timeouts (foro y an√°lisis comunitario muestran que APEX usa ese endpoint para emitir/extend). Cuando detecta p_reset_idle=Y reasigna lastActivityMs y permite que el watchdog se reprograme. Esto maneja el caso que mencionaste: si el usuario hace clic en Extend, recalcular tiempos. 
Oracle Forums

4) Qu√© hace el proceso On Demand (NOTIFY_SESSION_END) ‚Äî t√∫ implementas el SP real

El NOTIFY_SESSION_END es el puente entre el navegador y el procedimiento almacenado tuyo. En el ejemplo PL/SQL del punto 2 dej√© un NULL a modo de placeholder. Reempl√°zalo por la llamada real a tu procedimiento:

my_schema.mi_proc_notifica_fin_sesion(
  p_session_id => :APP_SESSION,
  p_user       => :APP_USER,
  p_app_id     => :APP_ID,
  p_reason     => apex_application.g_x01  -- o :P0_NOTIFY_REASON si quieres
);


El Application Process On Demand se invoca v√≠a apex.server.process('NOTIFY_SESSION_END', { x01: 'motivo' }) (como en el JS).

5) Garantizar ejecuci√≥n √∫nica y evitar falsos positivos

Bandera watchdogFired en JS evita ejecuciones m√∫ltiples.

Antes de invocar al proceso On Demand hacemos una √∫ltima comprobaci√≥n del tiempo restante (expiryMs - now) ‚Äî si hay m√°s de ~3s, re-agendamos: esto evita invocaciones por carrera si el reloj local cambia o llegan m√∫ltiples eventos casi simult√°neos.

Si el usuario extiende la sesi√≥n dentro de esos 2 segundos (o realiza actividad), el handler que intercepta la llamada ORDS o los eventos de usuario actualizar√° lastActivityMs, rescindir√° watchdogFired y reprogramar√°.

√önico caso en que la acci√≥n se repetir√° es el que pediste expl√≠citamente: el usuario extiende la sesi√≥n dentro de esos 2 segundos ‚Äî entonces se volver√° a ejecutar en el nuevo ciclo.

Observaci√≥n: hay reportes (foro oficial) de que si se pulsa Extend en los 3-4 segundos antes del aviso, APEX a veces hace una llamada con p_reset_idle=N y otra con p_reset_idle=Y generando comportamiento extra√±o; por eso interceptamos la URL de ORDS y no solo el bot√≥n visual. Esto mejora la fiabilidad. 
Oracle Forums

6) Pruebas sugeridas (paso a paso)

Precondici√≥n: en Shared Components ‚Üí Security has puesto 240 / 60 / 30 (como pediste).

Inicia sesi√≥n con un usuario de prueba.

Abre la consola del navegador (F12) y verifica window.__apexWatchdog.getState() para ver expiryMs y lastActivityMs.

No hagas nada: tras 58s de inactividad (ya que idle=60), el watchdog debe programarse para 2s antes y ejecutar el proceso (ver√°s la llamada AJAX a NOTIFY_SESSION_END).

Antes de los √∫ltimos 2s, haz clic en el Extend que APEX muestra: verifica que la llamada a ORDS /ords/apex_session.emit_timeouts?...p_reset_idle=Y sea detectada y que el watchdog se reprograme (la consola mostrar√° Detected ORDS extend).

Repite la prueba para maximum session length (240s) generando actividad que evite idle pero llegando al m√°ximo de vida y verifica que el watchdog tambi√©n lo calcule correctamente (esto prueba el min entre life y idle).

Comprueba en el log de tu procedimiento almacenado que la notificaci√≥n lleg√≥ una sola vez por expiraci√≥n.

7) Detalles de despliegue y checklist final

 Crear los Application Items P0_... (Page 0 o Application Items).

 Crear Application Process On New Instance que inicializa esos items.

 Crear Application Process On Demand NOTIFY_SESSION_END que invoque a tu SP (marcar autorizaci√≥n).

 Pegar el JS en Page 0 (Execute when Page Loads) o en un archivo JS est√°tico incluido globalmente.

 Probar con los valores 240/60/30 y ajustar si tu entorno tiene desfases (servidor vs cliente).

 Revisar logs y que tu procedimiento almacenado reciba: :APP_SESSION, :APP_USER, x01 (si necesitas motivo).

8) Consideraciones y buenas pr√°cticas

Reloj del cliente vs servidor: el c√°lculo se hace en el navegador (por latencia/UX). Si tu servidor necesita una precisi√≥n ¬±1s m√°s estricta, podr√≠amos consultar el servidor para hacer un NOW() antes de ejecutar (o usar apex.server.process tipo "pre-check" para validar). El enfoque actual es robusto para la mayor√≠a de usos de notificaci√≥n 2s antes.

Pesta√±as m√∫ltiples: el script se ejecuta por pesta√±a. Normalmente solo la pesta√±a activa tendr√° actividad; si tienes m√∫ltiples pesta√±as APEX usando la misma sesi√≥n, es posible que varias pesta√±as programen su watchdog. Para consolidar en un √∫nico disparador entre pesta√±as se puede usar localStorage + storage event para coordinar (puedo agregarlo si lo quieres).

Seguridad: protege el On Demand process con la autorizaci√≥n apropiada; no lo hagas p√∫blico.

Depuraci√≥n: el objeto window.__apexWatchdog expone funciones para pruebas.

9) C√≥digo y pasos listos para copiar (resumen r√°pido)

Shared Components ‚Üí Security ‚Üí Session Management: pon 240 / 60 / 30. 
Oracle Docs

Shared Components ‚Üí Application Items: crea P0_MAX_SESSION_LEN, P0_MAX_SESSION_IDLE, P0_SESSION_WARN, P0_SESSION_EXPIRY_TS, P0_LAST_ACTIVITY_TS.

Application Process (On New Instance): pega el PL/SQL de inicializaci√≥n del punto 1. 
Oracle Docs

Application Process (On Demand): NOTIFY_SESSION_END con la llamada a tu SP (puse ejemplo).

Page 0: pegar el JS watchdog completo (c√≥digo provisto arriba).

Si quieres, hago dos cosas ahora (elige una, no ambas):

A. Pego aqu√≠ mismo la versi√≥n del c√≥digo PL/SQL exacta si me confirmas el schema/namespace y el nombre del procedimiento almacenado que vas a usar (para que el Application Process haga la llamada real).
B. Extiendo el JS para coordinar entre pesta√±as usando localStorage (si tu aplicaci√≥n se usa mucho con m√∫ltiples pesta√±as y quieres evitar duplicados entre ellas).

Dime cu√°l prefieres y lo preparo inmediatamente (listo para pegar).