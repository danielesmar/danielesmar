Gemini:

-- =============================================================================
-- SISTEMA DE GESTIÓN DE TALENTO, CAPACITACIÓN Y VACACIONES
-- PLATAFORMA: ORACLE DATABASE (PARA ORACLE APEX)
-- AUTOR: GEMINI
-- DESCRIPCION: Script DDL para migración de Excel a BD Relacional
-- =============================================================================

-- 1. LIMPIEZA (Opcional, usar con cuidado en producción)
-- DROP TABLE REGISTRO_CAPACITACION CASCADE CONSTRAINTS;
-- DROP TABLE DETALLE_AVANCE_PROYECTO CASCADE CONSTRAINTS;
-- DROP TABLE ASIGNACION_PROYECTOS CASCADE CONSTRAINTS;
-- DROP TABLE PROYECTOS CASCADE CONSTRAINTS;
-- DROP TABLE SOLICITUD_VACACIONES CASCADE CONSTRAINTS;
-- DROP TABLE MATRIZ_COMPETENCIAS CASCADE CONSTRAINTS;
-- DROP TABLE COLABORADORES CASCADE CONSTRAINTS;
-- DROP TABLE COORDINACIONES CASCADE CONSTRAINTS;
-- DROP TABLE VICE_GERENCIAS CASCADE CONSTRAINTS;
-- DROP TABLE GERENCIAS CASCADE CONSTRAINTS;
-- DROP TABLE CAT_CURSOS CASCADE CONSTRAINTS;
-- DROP TABLE CAT_COMPETENCIAS CASCADE CONSTRAINTS;
-- DROP TABLE CAT_PROVEEDORES CASCADE CONSTRAINTS;
-- DROP TABLE FERIADOS CASCADE CONSTRAINTS;
-- DROP TABLE PERIODOS CASCADE CONSTRAINTS;

-- =============================================================================
-- 2. CATALOGOS ESTRUCTURALES Y ORGANIZATIVOS
-- =============================================================================

CREATE TABLE GERENCIAS (
    ID_GERENCIA NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NOMBRE_GERENCIA VARCHAR2(100) NOT NULL,
    SIGLAS VARCHAR2(20),
    HORAS_DIARIAS NUMBER(3,1) DEFAULT 9 NOT NULL, -- Configurable por gerencia (8 o 9 horas)
    TRABAJA_SABADOS CHAR(1) DEFAULT 'N' CHECK (TRABAJA_SABADOS IN ('S','N')),
    ACTIVO CHAR(1) DEFAULT 'S'
);

CREATE TABLE VICE_GERENCIAS (
    ID_VICE_GERENCIA NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ID_GERENCIA NUMBER REFERENCES GERENCIAS(ID_GERENCIA),
    NOMBRE_VICE VARCHAR2(100) NOT NULL, -- Ej: Base de Datos, Redes
    ACTIVO CHAR(1) DEFAULT 'S'
);

CREATE TABLE COORDINACIONES (
    ID_COORDINACION NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ID_VICE_GERENCIA NUMBER REFERENCES VICE_GERENCIAS(ID_VICE_GERENCIA),
    NOMBRE_EQUIPO VARCHAR2(100) NOT NULL,
    ACTIVO CHAR(1) DEFAULT 'S'
);

CREATE TABLE CARGOS (
    ID_CARGO NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NOMBRE_CARGO VARCHAR2(100) NOT NULL,
    NIVEL_JERARQUICO NUMBER -- 1: Gerente Gral, 2: Gerente, 3: Vice, 4: Coord, 5: Colab
);

-- =============================================================================
-- 3. CATALOGOS DE TIEMPO Y SISTEMA
-- =============================================================================

CREATE TABLE ANIOS_FISCALES (
    ANIO NUMBER(4) PRIMARY KEY, -- 2023, 2024, 2025
    ES_ACTUAL CHAR(1) DEFAULT 'N' CHECK (ES_ACTUAL IN ('S','N')),
    ESTADO VARCHAR2(20) DEFAULT 'ABIERTO' -- ABIERTO, CERRADO
);

CREATE TABLE PERIODOS (
    ID_PERIODO NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NOMBRE_PERIODO VARCHAR2(50) NOT NULL, -- I Trimestre, II Trimestre
    FECHA_INICIO DATE,
    FECHA_FIN DATE,
    ORDEN NUMBER -- 1, 2, 3, 4
);

CREATE TABLE FERIADOS (
    ID_FERIADO NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    FECHA DATE NOT NULL,
    DESCRIPCION VARCHAR2(100),
    VALOR_DIA NUMBER(3,2) DEFAULT 1.0, -- 1.0 dia completo, 0.5 medio dia
    ANIO NUMBER(4) REFERENCES ANIOS_FISCALES(ANIO),
    ES_RECURRENTE CHAR(1) DEFAULT 'N' -- Si se repite todos los años
);

-- =============================================================================
-- 4. RECURSOS HUMANOS (COLABORADORES)
-- =============================================================================

CREATE TABLE COLABORADORES (
    ID_COLABORADOR NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    CODIGO_EMPLEADO VARCHAR2(20) UNIQUE NOT NULL,
    NOMBRE_COMPLETO VARCHAR2(150) NOT NULL,
    EMAIL VARCHAR2(100) NOT NULL,
    FECHA_INGRESO DATE NOT NULL,
    
    -- Relaciones Organizativas
    ID_GERENCIA NUMBER REFERENCES GERENCIAS(ID_GERENCIA),
    ID_VICE_GERENCIA NUMBER REFERENCES VICE_GERENCIAS(ID_VICE_GERENCIA),
    ID_COORDINACION NUMBER REFERENCES COORDINACIONES(ID_COORDINACION),
    ID_CARGO NUMBER REFERENCES CARGOS(ID_CARGO),
    
    -- Jerarquia (Auto-referencia para saber quien es el jefe directo)
    ID_JEFE_DIRECTO NUMBER REFERENCES COLABORADORES(ID_COLABORADOR),
    
    -- Auditoria y Sistema
    USUARIO_APP VARCHAR2(50), -- Usuario de Oracle APEX / SSO asociado
    ESTADO CHAR(1) DEFAULT 'A' CHECK (ESTADO IN ('A','I')) -- Activo / Inactivo
);

-- Indices para busquedas rapidas
CREATE INDEX IDX_COLAB_JEFE ON COLABORADORES(ID_JEFE_DIRECTO);
CREATE INDEX IDX_COLAB_GERENCIA ON COLABORADORES(ID_GERENCIA);

-- =============================================================================
-- 5. CATALOGOS DE FORMACION Y COMPETENCIAS
-- =============================================================================

CREATE TABLE CAT_PROVEEDORES (
    ID_PROVEEDOR NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NOMBRE_PROVEEDOR VARCHAR2(100) NOT NULL -- Udemy, Microsoft, AuraQuantic
);

CREATE TABLE CAT_COMPETENCIAS (
    ID_COMPETENCIA NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NOMBRE_COMPETENCIA VARCHAR2(100) NOT NULL, -- Java, PL/SQL
    TIPO VARCHAR2(50) -- Técnica, Blanda, Idioma
);

CREATE TABLE CAT_CURSOS (
    ID_CURSO NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    NOMBRE_CURSO VARCHAR2(200) NOT NULL,
    ID_PROVEEDOR NUMBER REFERENCES CAT_PROVEEDORES(ID_PROVEEDOR),
    TIPO_CURSO VARCHAR2(50), -- Certificación, Curso Libre, Capacitación
    HORAS_ESTIMADAS NUMBER,
    COSTO NUMBER(10,2) DEFAULT 0
);

-- =============================================================================
-- 6. MODULO DE COMPETENCIAS (SKILL MATRIX)
-- =============================================================================

CREATE TABLE MATRIZ_COMPETENCIAS (
    ID_MATRIZ NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ID_COLABORADOR NUMBER REFERENCES COLABORADORES(ID_COLABORADOR) NOT NULL,
    ID_COMPETENCIA NUMBER REFERENCES CAT_COMPETENCIAS(ID_COMPETENCIA) NOT NULL,
    NIVEL_ACTUAL NUMBER(2) CHECK (NIVEL_ACTUAL BETWEEN 1 AND 10),
    NIVEL_DESEADO NUMBER(2) CHECK (NIVEL_DESEADO BETWEEN 1 AND 10),
    GAP AS (NIVEL_DESEADO - NIVEL_ACTUAL), -- Columna calculada virtual
    FECHA_ACTUALIZACION DATE DEFAULT SYSDATE,
    CONSTRAINT UK_MATRIZ UNIQUE (ID_COLABORADOR, ID_COMPETENCIA)
);

-- =============================================================================
-- 7. MODULO DE VACACIONES Y TIEMPO
-- =============================================================================

CREATE TABLE TIPO_AUSENCIA (
    ID_TIPO VARCHAR2(10) PRIMARY KEY, -- VAC, PER, ENF, SUB
    DESCRIPCION VARCHAR2(50),
    DESCUENTA_VACACIONES CHAR(1) DEFAULT 'S' -- Indica si resta del saldo
);

INSERT INTO TIPO_AUSENCIA VALUES ('VAC', 'Vacaciones', 'S');
INSERT INTO TIPO_AUSENCIA VALUES ('PER', 'Permiso sin goce', 'N');
INSERT INTO TIPO_AUSENCIA VALUES ('FER', 'Feriado', 'N'); -- Para registros manuales especiales

CREATE TABLE SOLICITUD_VACACIONES (
    ID_SOLICITUD NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ID_COLABORADOR NUMBER REFERENCES COLABORADORES(ID_COLABORADOR) NOT NULL,
    FECHA_INICIO DATE NOT NULL,
    FECHA_FIN DATE NOT NULL,
    ID_TIPO_AUSENCIA VARCHAR2(10) REFERENCES TIPO_AUSENCIA(ID_TIPO),
    
    -- Cantidad calculada en dias (ej: 0.5, 1.25, 5)
    CANTIDAD_DIAS NUMBER(5,2) NOT NULL, 
    
    OBSERVACIONES VARCHAR2(500),
    ESTADO VARCHAR2(20) DEFAULT 'SOLICITADO', -- SOLICITADO, APROBADO, RECHAZADO
    
    -- Campos de auditoria
    FECHA_SOLICITUD DATE DEFAULT SYSDATE,
    APROBADO_POR NUMBER REFERENCES COLABORADORES(ID_COLABORADOR)
);

-- =============================================================================
-- 8. MODULO DE PROYECTOS (INFORME SEMANAL)
-- =============================================================================

CREATE TABLE PROYECTOS (
    ID_PROYECTO NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    CODIGO_EXTERNO VARCHAR2(50) UNIQUE NOT NULL, -- Código del sistema externo
    NOMBRE_PROYECTO VARCHAR2(200) NOT NULL,
    DESCRIPCION VARCHAR2(4000),
    ESTADO_GLOBAL VARCHAR2(20) -- ANALISIS, DESARROLLO, FINALIZADO
);

CREATE TABLE ASIGNACION_PROYECTOS (
    ID_ASIGNACION NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ID_PROYECTO NUMBER REFERENCES PROYECTOS(ID_PROYECTO),
    ID_COLABORADOR NUMBER REFERENCES COLABORADORES(ID_COLABORADOR),
    ANIO NUMBER REFERENCES ANIOS_FISCALES(ANIO),
    ID_PERIODO NUMBER REFERENCES PERIODOS(ID_PERIODO),
    ROL_EN_PROYECTO VARCHAR2(50),
    PORCENTAJE_AVANCE_TOTAL NUMBER(3) DEFAULT 0 CHECK (PORCENTAJE_AVANCE_TOTAL BETWEEN 0 AND 100),
    ACTIVO CHAR(1) DEFAULT 'S'
);

CREATE TABLE BITACORA_SEMANAL (
    ID_BITACORA NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ID_ASIGNACION NUMBER REFERENCES ASIGNACION_PROYECTOS(ID_ASIGNACION),
    NUMERO_SEMANA NUMBER(2), -- Semana 1 al 52
    FECHA_REGISTRO DATE DEFAULT SYSDATE,
    COMENTARIO_AVANCE VARCHAR2(4000), -- Resumen ejecutivo
    PORCENTAJE_REPORTADO NUMBER(3) -- El % en ese momento
);

-- =============================================================================
-- 9. MODULO DE CAPACITACION Y AUTOESTUDIO
-- =============================================================================

CREATE TABLE PLAN_CAPACITACION (
    ID_PLAN NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ID_COLABORADOR NUMBER REFERENCES COLABORADORES(ID_COLABORADOR),
    ID_CURSO NUMBER REFERENCES CAT_CURSOS(ID_CURSO),
    ANIO NUMBER REFERENCES ANIOS_FISCALES(ANIO),
    ID_PERIODO NUMBER REFERENCES PERIODOS(ID_PERIODO), -- Trimestre
    
    ESTADO_CURSO VARCHAR2(20) DEFAULT 'PENDIENTE', -- PENDIENTE, EN_CURSO, FINALIZADO
    FECHA_INICIO DATE,
    FECHA_FIN DATE,
    
    -- Metricas
    HORAS_PLAN NUMBER(5,2),
    HORAS_CURSADAS_REALES NUMBER(5,2),
    AVANCE_PORCENTAJE NUMBER(3),
    
    -- Evaluación de conocimiento (Pre y Post)
    NIVEL_INICIAL NUMBER(2),
    NIVEL_FINAL NUMBER(2),
    
    EVIDENCIA_CERTIFICADO BLOB, -- Para guardar el PDF/IMG del certificado
    MIMETYPE VARCHAR2(255),
    FILENAME VARCHAR2(255),
    LAST_UPDATE DATE
);

-- =============================================================================
-- 10. PAQUETES Y FUNCIONES DE NEGOCIO (CORE DEL SISTEMA)
-- =============================================================================

CREATE OR REPLACE PACKAGE PKG_TALENTO_HUMANO AS
    -- Calcula dias laborales netos entre dos fechas (excluye fines de semana y feriados)
    FUNCTION FN_CALCULAR_DIAS_LABORALES(
        p_fecha_inicio DATE, 
        p_fecha_fin DATE, 
        p_id_gerencia NUMBER
    ) RETURN NUMBER;

    -- Calcula horas objetivo de estudio (1 hora por dia laboral neto)
    FUNCTION FN_CALCULAR_HORAS_ESTUDIO(
        p_id_colaborador NUMBER,
        p_id_periodo NUMBER,
        p_anio NUMBER
    ) RETURN NUMBER;

    -- Calcula dias de vacaciones disponibles
    FUNCTION FN_SALDO_VACACIONES(
        p_id_colaborador NUMBER
    ) RETURN NUMBER;
END PKG_TALENTO_HUMANO;
/

CREATE OR REPLACE PACKAGE BODY PKG_TALENTO_HUMANO AS

    FUNCTION FN_CALCULAR_DIAS_LABORALES(
        p_fecha_inicio DATE, 
        p_fecha_fin DATE, 
        p_id_gerencia NUMBER
    ) RETURN NUMBER IS
        v_dias_totales NUMBER := 0;
        v_fecha_actual DATE;
        v_trabaja_sabados CHAR(1);
        v_es_feriado NUMBER;
        v_valor_feriado NUMBER;
        v_dia_semana VARCHAR2(20);
    BEGIN
        -- Obtener configuracion de la gerencia
        SELECT TRABAJA_SABADOS INTO v_trabaja_sabados 
        FROM GERENCIAS WHERE ID_GERENCIA = p_id_gerencia;

        v_fecha_actual := p_fecha_inicio;

        WHILE v_fecha_actual <= p_fecha_fin LOOP
            -- Determinar dia de la semana (1=Domingo, 7=Sabado)
            -- Nota: Usamos to_char con 'D' o aritmetica para ser independientes del idioma
            -- 1: Domingo, 7: Sabado (depende de NLS, mejor usar 'DY' en ingles)
            v_dia_semana := TO_CHAR(v_fecha_actual, 'DY', 'NLS_DATE_LANGUAGE=ENGLISH');

            -- Regla 1: Domingos nunca se trabajan
            IF v_dia_semana = 'SUN' THEN
                NULL; -- No suma
            -- Regla 2: Sabados depende de la gerencia
            ELSIF v_dia_semana = 'SAT' AND v_trabaja_sabados = 'N' THEN
                NULL; -- No suma
            ELSE
                -- Es dia de semana o sabado laborable. Verificar Feriados.
                BEGIN
                    SELECT VALOR_DIA INTO v_valor_feriado
                    FROM FERIADOS
                    WHERE TRUNC(FECHA) = TRUNC(v_fecha_actual);
                    
                    -- Si hay feriado, se trabaja (1 - valor_feriado). 
                    -- Ej: Feriado completo (1.0) -> se trabaja 0.
                    -- Ej: Medio dia (0.5) -> se trabaja 0.5.
                    v_dias_totales := v_dias_totales + (1 - v_valor_feriado);
                EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                        -- No es feriado, dia completo
                        v_dias_totales := v_dias_totales + 1;
                END;
            END IF;

            v_fecha_actual := v_fecha_actual + 1;
        END LOOP;

        RETURN v_dias_totales;
    END FN_CALCULAR_DIAS_LABORALES;

    FUNCTION FN_CALCULAR_HORAS_ESTUDIO(
        p_id_colaborador NUMBER,
        p_id_periodo NUMBER,
        p_anio NUMBER
    ) RETURN NUMBER IS
        v_fecha_inicio DATE;
        v_fecha_fin DATE;
        v_id_gerencia NUMBER;
        v_dias_laborales NUMBER;
        v_dias_vacaciones NUMBER;
        v_horas_objetivo NUMBER;
        v_fecha_ingreso DATE;
    BEGIN
        -- 1. Obtener rango de fechas del periodo
        SELECT FECHA_INICIO, FECHA_FIN INTO v_fecha_inicio, v_fecha_fin
        FROM PERIODOS WHERE ID_PERIODO = p_id_periodo;
        
        -- Ajustar año si el periodo es genérico (catalogo fijo) a las fechas del año actual
        -- Nota: En una implementación real, PERIODOS debería estar ligado a ANIO o tener fechas reales.
        -- Asumiremos que FECHA_INICIO/FIN en PERIODOS tienen el año correcto o se construyen.
        
        -- 2. Obtener datos colaborador
        SELECT ID_GERENCIA, FECHA_INGRESO INTO v_id_gerencia, v_fecha_ingreso
        FROM COLABORADORES WHERE ID_COLABORADOR = p_id_colaborador;

        -- Ajustar fecha inicio si el colaborador entró DESPUES de iniciar el trimestre
        IF v_fecha_ingreso > v_fecha_inicio THEN
            v_fecha_inicio := v_fecha_ingreso;
        END IF;

        IF v_fecha_inicio > v_fecha_fin THEN
            RETURN 0; -- Ingresó después del trimestre
        END IF;

        -- 3. Calcular Dias Laborales Teoricos (sin vacaciones)
        v_dias_laborales := FN_CALCULAR_DIAS_LABORALES(v_fecha_inicio, v_fecha_fin, v_id_gerencia);

        -- 4. Restar dias/horas no trabajadas por Vacaciones o Permisos en ese periodo
        -- Según requerimiento: "si se pide 0.5 dias... el contador para ese dia no cuenta"
        SELECT NVL(SUM(CANTIDAD_DIAS), 0)
        INTO v_dias_vacaciones
        FROM SOLICITUD_VACACIONES
        WHERE ID_COLABORADOR = p_id_colaborador
          AND ESTADO = 'APROBADO'
          AND FECHA_INICIO BETWEEN v_fecha_inicio AND v_fecha_fin;

        -- 5. Calculo final: 1 hora por dia laborado efectivo
        v_horas_objetivo := (v_dias_laborales - v_dias_vacaciones) * 1; 

        RETURN GREATEST(v_horas_objetivo, 0);
    END FN_CALCULAR_HORAS_ESTUDIO;

    FUNCTION FN_SALDO_VACACIONES(p_id_colaborador NUMBER) RETURN NUMBER IS
        v_fecha_ingreso DATE;
        v_meses_trabajados NUMBER;
        v_dias_acumulados NUMBER;
        v_dias_gozados NUMBER;
    BEGIN
        SELECT FECHA_INGRESO INTO v_fecha_ingreso 
        FROM COLABORADORES WHERE ID_COLABORADOR = p_id_colaborador;

        -- Regla: 2.5 dias por mes (30 dias al año)
        v_meses_trabajados := MONTHS_BETWEEN(SYSDATE, v_fecha_ingreso);
        v_dias_acumulados := v_meses_trabajados * 2.5;

        -- Restar dias gozados (Solo tipo VAC)
        SELECT NVL(SUM(CANTIDAD_DIAS), 0) INTO v_dias_gozados
        FROM SOLICITUD_VACACIONES
        WHERE ID_COLABORADOR = p_id_colaborador
          AND ID_TIPO_AUSENCIA = 'VAC'
          AND ESTADO = 'APROBADO';

        RETURN ROUND(v_dias_acumulados - v_dias_gozados, 2);
    END FN_SALDO_VACACIONES;

END PKG_TALENTO_HUMANO;
/

-- =============================================================================
-- 11. VISTAS Y REPORTES
-- =============================================================================

-- Vista Dashboard Gerencial: Avance de Capacitación
CREATE OR REPLACE VIEW V_DASHBOARD_CAPACITACION AS
SELECT 
    c.ID_COLABORADOR,
    c.NOMBRE_COMPLETO,
    g.NOMBRE_GERENCIA,
    p.NOMBRE_PERIODO,
    a.ANIO,
    -- Calculo dinámico usando el paquete
    PKG_TALENTO_HUMANO.FN_CALCULAR_HORAS_ESTUDIO(c.ID_COLABORADOR, p.ID_PERIODO, a.ANIO) as META_HORAS,
    SUM(pc.HORAS_CURSADAS_REALES) as HORAS_REALIZADAS,
    CASE 
        WHEN PKG_TALENTO_HUMANO.FN_CALCULAR_HORAS_ESTUDIO(c.ID_COLABORADOR, p.ID_PERIODO, a.ANIO) > 0 
        THEN ROUND((SUM(pc.HORAS_CURSADAS_REALES) / PKG_TALENTO_HUMANO.FN_CALCULAR_HORAS_ESTUDIO(c.ID_COLABORADOR, p.ID_PERIODO, a.ANIO)) * 100, 2)
        ELSE 0 
    END as CUMPLIMIENTO_PORCENTAJE
FROM COLABORADORES c
JOIN GERENCIAS g ON c.ID_GERENCIA = g.ID_GERENCIA
CROSS JOIN ANIOS_FISCALES a
CROSS JOIN PERIODOS p
LEFT JOIN PLAN_CAPACITACION pc ON pc.ID_COLABORADOR = c.ID_COLABORADOR 
    AND pc.ANIO = a.ANIO 
    AND pc.ID_PERIODO = p.ID_PERIODO
WHERE a.ES_ACTUAL = 'S'
GROUP BY c.ID_COLABORADOR, c.NOMBRE_COMPLETO, g.NOMBRE_GERENCIA, p.NOMBRE_PERIODO, p.ID_PERIODO, a.ANIO;

-- Vista Informe Semanal Detallado
CREATE OR REPLACE VIEW V_INFORME_SEMANAL_PROYECTOS AS
SELECT 
    b.NUMERO_SEMANA,
    p.NOMBRE_PERIODO,
    col.NOMBRE_COMPLETO,
    pro.NOMBRE_PROYECTO,
    pro.CODIGO_EXTERNO,
    ap.ROL_EN_PROYECTO,
    b.COMENTARIO_AVANCE,
    b.PORCENTAJE_REPORTADO,
    b.FECHA_REGISTRO
FROM BITACORA_SEMANAL b
JOIN ASIGNACION_PROYECTOS ap ON b.ID_ASIGNACION = ap.ID_ASIGNACION
JOIN PROYECTOS pro ON ap.ID_PROYECTO = pro.ID_PROYECTO
JOIN COLABORADORES col ON ap.ID_COLABORADOR = col.ID_COLABORADOR
JOIN PERIODOS p ON ap.ID_PERIODO = p.ID_PERIODO
ORDER BY b.NUMERO_SEMANA DESC, col.NOMBRE_COMPLETO;

-- =============================================================================
-- 12. TRIGGERS DE AUTOMATIZACION
-- =============================================================================

-- Actualizar porcentaje en Asignacion cuando se reporta en bitacora
CREATE OR REPLACE TRIGGER TRG_ACTUALIZA_AVANCE_PROY
AFTER INSERT OR UPDATE ON BITACORA_SEMANAL
FOR EACH ROW
BEGIN
    UPDATE ASIGNACION_PROYECTOS
    SET PORCENTAJE_AVANCE_TOTAL = :NEW.PORCENTAJE_REPORTADO
    WHERE ID_ASIGNACION = :NEW.ID_ASIGNACION;
END;
/

-- =============================================================================
-- 13. DATOS SEMILLA (SEED DATA)
-- =============================================================================

-- Trimestres Fijos
INSERT INTO PERIODOS (NOMBRE_PERIODO, ORDEN) VALUES ('I Trimestre', 1);
INSERT INTO PERIODOS (NOMBRE_PERIODO, ORDEN) VALUES ('II Trimestre', 2);
INSERT INTO PERIODOS (NOMBRE_PERIODO, ORDEN) VALUES ('III Trimestre', 3);
INSERT INTO PERIODOS (NOMBRE_PERIODO, ORDEN) VALUES ('IV Trimestre', 4);

-- Año Inicial
INSERT INTO ANIOS_FISCALES (ANIO, ES_ACTUAL, ESTADO) VALUES (2025, 'S', 'ABIERTO');

COMMIT;

-- Fin del Script Actualizado






*****************************************

deepseek:

-- Tabla para los años
CREATE TABLE ANIO (
    anio_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    anio NUMBER(4) NOT NULL UNIQUE,
    activo CHAR(1) DEFAULT 'S' CHECK (activo IN ('S', 'N')),
    fecha_creacion TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- Tabla para los periodos (trimestres fijos)
CREATE TABLE PERIODO (
    periodo_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre VARCHAR2(20) NOT NULL UNIQUE, -- 'I Trimestre', 'II Trimestre', etc.
    numero NUMBER(1) NOT NULL UNIQUE CHECK (numero BETWEEN 1 AND 4),
    activo CHAR(1) DEFAULT 'S' CHECK (activo IN ('S', 'N'))
);

-- Insertar los periodos fijos
INSERT INTO PERIODO (nombre, numero) VALUES ('I Trimestre', 1);
INSERT INTO PERIODO (nombre, numero) VALUES ('II Trimestre', 2);
INSERT INTO PERIODO (nombre, numero) VALUES ('III Trimestre', 3);
INSERT INTO PERIODO (nombre, numero) VALUES ('IV Trimestre', 4);

-- Tabla para las unidades organizacionales (jerárquica)
CREATE TABLE UNIDAD_ORGANIZACIONAL (
    unidad_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre VARCHAR2(100) NOT NULL,
    codigo VARCHAR2(20) UNIQUE,
    unidad_padre_id NUMBER,
    nivel_jerarquia NUMBER(2), -- 1: Gerencia General, 2: Gerencia, 3: Vicegerencia, 4: Coordinación, etc.
    activo CHAR(1) DEFAULT 'S' CHECK (activo IN ('S', 'N')),
    FOREIGN KEY (unidad_padre_id) REFERENCES UNIDAD_ORGANIZACIONAL(unidad_id)
);

-- Tabla para los cargos
CREATE TABLE CARGO (
    cargo_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre VARCHAR2(100) NOT NULL UNIQUE,
    activo CHAR(1) DEFAULT 'S' CHECK (activo IN ('S', 'N'))
);

-- Tabla para los empleados (colaboradores)
CREATE TABLE EMPLEADO (
    empleado_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    codigo VARCHAR2(20) UNIQUE NOT NULL,
    nombre VARCHAR2(200) NOT NULL,
    unidad_organizacional_id NUMBER NOT NULL,
    cargo_id NUMBER NOT NULL,
    fecha_ingreso DATE NOT NULL,
    activo CHAR(1) DEFAULT 'S' CHECK (activo IN ('S', 'N')),
    email VARCHAR2(100),
    FOREIGN KEY (unidad_organizacional_id) REFERENCES UNIDAD_ORGANIZACIONAL(unidad_id),
    FOREIGN KEY (cargo_id) REFERENCES CARGO(cargo_id)
);

-- Tabla para los emisores (entidades que emiten cursos/certificaciones)
CREATE TABLE EMISOR (
    emisor_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre VARCHAR2(100) NOT NULL UNIQUE,
    activo CHAR(1) DEFAULT 'S' CHECK (activo IN ('S', 'N'))
);

-- Tabla para los estados de curso
CREATE TABLE ESTADO_CURSO (
    estado_curso_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre VARCHAR2(50) NOT NULL UNIQUE, -- Finalizado, Pendiente, En curso
    activo CHAR(1) DEFAULT 'S' CHECK (activo IN ('S', 'N'))
);

-- Tabla para las competencias (habilidades)
CREATE TABLE COMPETENCIA (
    competencia_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre VARCHAR2(100) NOT NULL UNIQUE,
    descripcion VARCHAR2(500),
    activo CHAR(1) DEFAULT 'S' CHECK (activo IN ('S', 'N'))
);

-- Tabla para los cursos/certificaciones
CREATE TABLE CURSO (
    curso_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre VARCHAR2(200) NOT NULL,
    emisor_id NUMBER,
    competencia_id NUMBER, -- La competencia principal que se desarrolla
    descripcion VARCHAR2(1000),
    horas_planificadas NUMBER(5,2), -- Duración total en horas
    activo CHAR(1) DEFAULT 'S' CHECK (activo IN ('S', 'N')),
    FOREIGN KEY (emisor_id) REFERENCES EMISOR(emisor_id),
    FOREIGN KEY (competencia_id) REFERENCES COMPETENCIA(competencia_id)
);

-- Tabla para los proyectos
CREATE TABLE PROYECTO (
    proyecto_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    codigo_externo VARCHAR2(50) UNIQUE NOT NULL, -- Código generado por un sistema externo
    nombre VARCHAR2(200) NOT NULL,
    descripcion VARCHAR2(1000),
    unidad_organizacional_id NUMBER, -- Unidad responsable del proyecto
    activo CHAR(1) DEFAULT 'S' CHECK (activo IN ('S', 'N')),
    FOREIGN KEY (unidad_organizacional_id) REFERENCES UNIDAD_ORGANIZACIONAL(unidad_id)
);

-- Tabla para los tipos de ausencia (vacaciones, permisos, feriados, subsidios, etc.)
CREATE TABLE TIPO_AUSENCIA (
    tipo_ausencia_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre VARCHAR2(50) NOT NULL UNIQUE, -- Vacaciones, Permiso, Feriado, Subsidio, etc.
    descripcion VARCHAR2(200),
    afecta_vacaciones CHAR(1) DEFAULT 'N' CHECK (afecta_vacaciones IN ('S', 'N')), -- Si consume días de vacaciones
    afecta_estudio CHAR(1) DEFAULT 'S' CHECK (afecta_estudio IN ('S', 'N')), -- Si afecta el cálculo de horas de estudio (no se cuenta el día)
    medio_dia CHAR(1) DEFAULT 'N' CHECK (medio_dia IN ('S', 'N')), -- Si es de medio día (0.5 días)
    activo CHAR(1) DEFAULT 'S' CHECK (activo IN ('S', 'N'))
);

-- Tabla para el calendario laboral (días específicos del año)
CREATE TABLE CALENDARIO_LABORAL (
    calendario_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    fecha DATE NOT NULL UNIQUE,
    dia_semana VARCHAR2(10), -- Lunes, Martes, etc.
    es_laboral CHAR(1) DEFAULT 'S' CHECK (es_laboral IN ('S', 'N')), -- Si es día laboral (excluyendo fines de semana y feriados)
    tipo_ausencia_id NUMBER, -- Si es feriado o algún tipo de día especial
    horas_laborales NUMBER(4,2) DEFAULT 9.0, -- Horas laborales en ese día (puede variar por día)
    anio_id NUMBER NOT NULL,
    periodo_id NUMBER, -- Trimestre al que pertenece
    FOREIGN KEY (tipo_ausencia_id) REFERENCES TIPO_AUSENCIA(tipo_ausencia_id),
    FOREIGN KEY (anio_id) REFERENCES ANIO(anio_id),
    FOREIGN KEY (periodo_id) REFERENCES PERIODO(periodo_id)
);

-- Tabla para las ausencias de los empleados (vacaciones, permisos, etc.)
CREATE TABLE AUSENCIA (
    ausencia_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    empleado_id NUMBER NOT NULL,
    tipo_ausencia_id NUMBER NOT NULL,
    fecha_inicio DATE NOT NULL,
    fecha_fin DATE NOT NULL,
    horas NUMBER(5,2) NOT NULL, -- Horas de ausencia (puede ser 9 para un día completo, 4.5 para medio día, etc.)
    dias NUMBER(5,2) NOT NULL, -- Días de ausencia (1, 0.5, etc.)
    observaciones VARCHAR2(500),
    anio_id NUMBER NOT NULL,
    periodo_id NUMBER NOT NULL,
    fecha_registro TIMESTAMP DEFAULT SYSTIMESTAMP,
    FOREIGN KEY (empleado_id) REFERENCES EMPLEADO(empleado_id),
    FOREIGN KEY (tipo_ausencia_id) REFERENCES TIPO_AUSENCIA(tipo_ausencia_id),
    FOREIGN KEY (anio_id) REFERENCES ANIO(anio_id),
    FOREIGN KEY (periodo_id) REFERENCES PERIODO(periodo_id)
);

-- Tabla para las competencias de los empleados (nivel actual, deseado, etc.)
CREATE TABLE EMPLEADO_COMPETENCIA (
    empleado_competencia_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    empleado_id NUMBER NOT NULL,
    competencia_id NUMBER NOT NULL,
    nivel_actual NUMBER(2) CHECK (nivel_actual BETWEEN 1 AND 10),
    nivel_deseado NUMBER(2) CHECK (nivel_deseado BETWEEN 1 AND 10),
    gap NUMBER(2) GENERATED ALWAYS AS (nivel_deseado - nivel_actual) VIRTUAL,
    fecha_actualizacion TIMESTAMP DEFAULT SYSTIMESTAMP,
    UNIQUE (empleado_id, competencia_id),
    FOREIGN KEY (empleado_id) REFERENCES EMPLEADO(empleado_id),
    FOREIGN KEY (competencia_id) REFERENCES COMPETENCIA(competencia_id)
);

-- Tabla para el registro de cursos de los empleados (matrícula en curso)
CREATE TABLE EMPLEADO_CURSO (
    empleado_curso_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    empleado_id NUMBER NOT NULL,
    curso_id NUMBER NOT NULL,
    anio_id NUMBER NOT NULL,
    periodo_id NUMBER NOT NULL,
    estado_curso_id NUMBER NOT NULL,
    fecha_inicio DATE,
    fecha_fin DATE,
    horas_cursadas NUMBER(5,2) DEFAULT 0,
    porcentaje_avance NUMBER(5,2) DEFAULT 0,
    nivel_conocimiento_inicial NUMBER(2) CHECK (nivel_conocimiento_inicial BETWEEN 1 AND 10),
    nivel_conocimiento_final NUMBER(2) CHECK (nivel_conocimiento_final BETWEEN 1 AND 10),
    costo NUMBER(10,2) DEFAULT 0,
    observaciones VARCHAR2(500),
    fecha_registro TIMESTAMP DEFAULT SYSTIMESTAMP,
    FOREIGN KEY (empleado_id) REFERENCES EMPLEADO(empleado_id),
    FOREIGN KEY (curso_id) REFERENCES CURSO(curso_id),
    FOREIGN KEY (anio_id) REFERENCES ANIO(anio_id),
    FOREIGN KEY (periodo_id) REFERENCES PERIODO(periodo_id),
    FOREIGN KEY (estado_curso_id) REFERENCES ESTADO_CURSO(estado_curso_id)
);

-- Tabla para el registro de proyectos de los empleados (asignación de proyectos)
CREATE TABLE EMPLEADO_PROYECTO (
    empleado_proyecto_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    empleado_id NUMBER NOT NULL,
    proyecto_id NUMBER NOT NULL,
    anio_id NUMBER NOT NULL,
    periodo_id NUMBER NOT NULL,
    estado_proyecto VARCHAR2(50) CHECK (estado_proyecto IN ('Analisis', 'Desarrollo', 'Cancelado', 'Soporte', 'Finalizado', 'Suspendido')),
    porcentaje_avance NUMBER(5,2) DEFAULT 0,
    fecha_asignacion DATE DEFAULT SYSDATE,
    fecha_fin DATE,
    activo CHAR(1) DEFAULT 'S' CHECK (activo IN ('S', 'N')),
    FOREIGN KEY (empleado_id) REFERENCES EMPLEADO(empleado_id),
    FOREIGN KEY (proyecto_id) REFERENCES PROYECTO(proyecto_id),
    FOREIGN KEY (anio_id) REFERENCES ANIO(anio_id),
    FOREIGN KEY (periodo_id) REFERENCES PERIODO(periodo_id)
);

-- Tabla para los informes semanales de proyectos (seguimiento)
CREATE TABLE INFORME_SEMANAL (
    informe_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    empleado_proyecto_id NUMBER NOT NULL,
    semana NUMBER(2), -- Número de semana dentro del trimestre (1 a 13 aproximadamente)
    fecha_informe DATE DEFAULT SYSDATE,
    descripcion VARCHAR2(2000),
    porcentaje_avance_semana NUMBER(5,2), -- Avance en esta semana
    horas_dedicadas NUMBER(5,2),
    FOREIGN KEY (empleado_proyecto_id) REFERENCES EMPLEADO_PROYECTO(empleado_proyecto_id)
);

-- Tabla para la configuración de horas laborales por unidad organizacional (o por gerencia)
CREATE TABLE CONFIG_HORAS_LABORALES (
    config_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    unidad_organizacional_id NUMBER NOT NULL,
    horas_diarias NUMBER(4,2) DEFAULT 9.0,
    dias_semana NUMBER(1) DEFAULT 5, -- 5 o 6 días a la semana
    aplica_autoestudio CHAR(1) DEFAULT 'S' CHECK (aplica_autoestudio IN ('S', 'N')), -- Si la gerencia aplica autoestudio
    horas_autoestudio_diarias NUMBER(4,2) DEFAULT 1.0, -- Horas de autoestudio por día laboral
    activo CHAR(1) DEFAULT 'S' CHECK (activo IN ('S', 'N')),
    FOREIGN KEY (unidad_organizacional_id) REFERENCES UNIDAD_ORGANIZACIONAL(unidad_id)
);

-- Tabla para el registro de horas de estudio (autoestudio) de los empleados
CREATE TABLE REGISTRO_HORAS_ESTUDIO (
    registro_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    empleado_id NUMBER NOT NULL,
    fecha DATE NOT NULL,
    horas NUMBER(5,2) NOT NULL,
    empleado_curso_id NUMBER NOT NULL, -- Curso al que se dedican las horas
    observaciones VARCHAR2(500),
    FOREIGN KEY (empleado_id) REFERENCES EMPLEADO(empleado_id),
    FOREIGN KEY (empleado_curso_id) REFERENCES EMPLEADO_CURSO(empleado_curso_id)
);

-- Tabla para los días de vacaciones acumulados de los empleados (por año)
CREATE TABLE VACACIONES_ACUMULADAS (
    vacacion_acumulada_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    empleado_id NUMBER NOT NULL,
    anio_id NUMBER NOT NULL,
    dias_acumulados NUMBER(5,2) DEFAULT 0,
    dias_gozados NUMBER(5,2) DEFAULT 0,
    saldo NUMBER(5,2) GENERATED ALWAYS AS (dias_acumulados - dias_gozados) VIRTUAL,
    FOREIGN KEY (empleado_id) REFERENCES EMPLEADO(empleado_id),
    FOREIGN KEY (anio_id) REFERENCES ANIO(anio_id),
    UNIQUE (empleado_id, anio_id)
);

-- Índices para mejorar el rendimiento en búsquedas comunes
CREATE INDEX idx_empleado_unidad ON EMPLEADO(unidad_organizacional_id);
CREATE INDEX idx_empleado_cargo ON EMPLEADO(cargo_id);
CREATE INDEX idx_ausencia_empleado ON AUSENCIA(empleado_id);
CREATE INDEX idx_ausencia_fechas ON AUSENCIA(fecha_inicio, fecha_fin);
CREATE INDEX idx_calendario_fecha ON CALENDARIO_LABORAL(fecha);
CREATE INDEX idx_empleado_curso_empleado ON EMPLEADO_CURSO(empleado_id);
CREATE INDEX idx_empleado_curso_curso ON EMPLEADO_CURSO(curso_id);
CREATE INDEX idx_empleado_proyecto_empleado ON EMPLEADO_PROYECTO(empleado_id);
CREATE INDEX idx_empleado_proyecto_proyecto ON EMPLEADO_PROYECTO(proyecto_id);
CREATE INDEX idx_informe_semanal_empleado_proyecto ON INFORME_SEMANAL(empleado_proyecto_id);
CREATE INDEX idx_registro_horas_estudio_empleado ON REGISTRO_HORAS_ESTUDIO(empleado_id);
CREATE INDEX idx_registro_horas_estudio_curso ON REGISTRO_HORAS_ESTUDIO(empleado_curso_id);

-- Vistas para facilitar consultas

-- Vista para la jerarquía organizacional (empleado y su jefe inmediato, si es que tiene)
-- Asumimos que el jefe de un empleado es el que está a cargo de la unidad organizacional, pero esto puede ser más complejo.
-- Por simplicidad, podemos tener una vista que muestre el empleado y su unidad, y la unidad padre (si existe) y el jefe de esa unidad.
-- Sin embargo, no tenemos una tabla que asigne jefes a unidades. Podemos agregar un campo en la tabla UNIDAD_ORGANIZACIONAL para el empleado que es el jefe.
-- O podemos tener una tabla aparte para los jefes de unidad.

-- Vamos a agregar un campo en UNIDAD_ORGANIZACIONAL para el empleado jefe (opcional, ya que puede haber unidades sin jefe asignado).
ALTER TABLE UNIDAD_ORGANIZACIONAL ADD (jefe_empleado_id NUMBER);
ALTER TABLE UNIDAD_ORGANIZACIONAL ADD FOREIGN KEY (jefe_empleado_id) REFERENCES EMPLEADO(empleado_id);

-- Vista para ver los empleados con su unidad y jefe de unidad
CREATE OR REPLACE VIEW V_EMPLEADO_JERARQUIA AS
SELECT 
    e.empleado_id,
    e.codigo,
    e.nombre as empleado_nombre,
    e.unidad_organizacional_id,
    u.nombre as unidad_nombre,
    u.unidad_padre_id,
    u.jefe_empleado_id,
    j.nombre as jefe_nombre
FROM EMPLEADO e
JOIN UNIDAD_ORGANIZACIONAL u ON e.unidad_organizacional_id = u.unidad_id
LEFT JOIN EMPLEADO j ON u.jefe_empleado_id = j.empleado_id;

-- Vista para los días laborales por trimestre y año (conteo de días laborales)
CREATE OR REPLACE VIEW V_DIAS_LABORALES_TRIMESTRE AS
SELECT 
    anio_id,
    periodo_id,
    COUNT(*) as dias_laborales,
    SUM(horas_laborales) as horas_laborales
FROM CALENDARIO_LABORAL
WHERE es_laboral = 'S'
GROUP BY anio_id, periodo_id;

-- Vista para las vacaciones acumuladas y saldo de los empleados
CREATE OR REPLACE VIEW V_VACACIONES_SALDO AS
SELECT 
    va.empleado_id,
    e.nombre as empleado_nombre,
    a.anio,
    va.dias_acumulados,
    va.dias_gozados,
    va.saldo
FROM VACACIONES_ACUMULADAS va
JOIN EMPLEADO e ON va.empleado_id = e.empleado_id
JOIN ANIO a ON va.anio_id = a.anio_id;

-- Vista para el avance de cursos por empleado y trimestre
CREATE OR REPLACE VIEW V_AVANCE_CURSOS AS
SELECT 
    ec.empleado_id,
    e.nombre as empleado_nombre,
    ec.anio_id,
    ec.periodo_id,
    c.nombre as curso_nombre,
    ec.horas_cursadas,
    c.horas_planificadas,
    ec.porcentaje_avance,
    ec.nivel_conocimiento_inicial,
    ec.nivel_conocimiento_final,
    es.nombre as estado_curso
FROM EMPLEADO_CURSO ec
JOIN EMPLEADO e ON ec.empleado_id = e.empleado_id
JOIN CURSO c ON ec.curso_id = c.curso_id
JOIN ESTADO_CURSO es ON ec.estado_curso_id = es.estado_curso_id;

-- Vista para el avance de proyectos por empleado y trimestre
CREATE OR REPLACE VIEW V_AVANCE_PROYECTOS AS
SELECT 
    ep.empleado_id,
    e.nombre as empleado_nombre,
    ep.anio_id,
    ep.periodo_id,
    p.nombre as proyecto_nombre,
    ep.estado_proyecto,
    ep.porcentaje_avance,
    ep.fecha_asignacion,
    ep.fecha_fin
FROM EMPLEADO_PROYECTO ep
JOIN EMPLEADO e ON ep.empleado_id = e.empleado_id
JOIN PROYECTO p ON ep.proyecto_id = p.proyecto_id;

-- También necesitaremos procedimientos almacenados y funciones para cálculos complejos, como:
-- 1. Calcular días laborales entre dos fechas para un empleado, considerando su unidad organizacional (horarios y días laborales).
-- 2. Calcular horas de autoestudio requeridas por trimestre para un empleado.
-- 3. Calcular vacaciones acumuladas y saldo.
-- 4. Notificaciones por correo (esto puede hacerse con jobs y procedimientos, pero el envío de correo requiere configuración de Oracle).

-- Por ahora, vamos a crear una función para calcular los días laborales entre dos fechas para un empleado, considerando el calendario laboral.

CREATE OR REPLACE FUNCTION F_DIAS_LABORALES (
    p_empleado_id IN NUMBER,
    p_fecha_inicio IN DATE,
    p_fecha_fin IN DATE
) RETURN NUMBER IS
    v_dias NUMBER := 0;
BEGIN
    SELECT COUNT(*)
    INTO v_dias
    FROM CALENDARIO_LABORAL c
    WHERE c.fecha BETWEEN p_fecha_inicio AND p_fecha_fin
        AND c.es_laboral = 'S'
        AND NOT EXISTS (
            SELECT 1
            FROM AUSENCIA a
            WHERE a.empleado_id = p_empleado_id
                AND a.tipo_ausencia_id IN (SELECT tipo_ausencia_id FROM TIPO_AUSENCIA WHERE afecta_estudio = 'S')
                AND c.fecha BETWEEN a.fecha_inicio AND a.fecha_fin
        );
    RETURN v_dias;
END;
/

-- Función para calcular las horas de autoestudio requeridas para un empleado en un trimestre.
-- Esto depende de la configuración de la unidad del empleado y de los días laborales del trimestre, menos las ausencias.

CREATE OR REPLACE FUNCTION F_HORAS_AUTOESTUDIO_TRIMESTRE (
    p_empleado_id IN NUMBER,
    p_anio_id IN NUMBER,
    p_periodo_id IN NUMBER
) RETURN NUMBER IS
    v_horas_autoestudio_diarias NUMBER;
    v_dias_laborales NUMBER;
    v_unidad_id NUMBER;
BEGIN
    -- Obtener la unidad del empleado y la configuración de horas de autoestudio
    SELECT e.unidad_organizacional_id
    INTO v_unidad_id
    FROM EMPLEADO e
    WHERE e.empleado_id = p_empleado_id;

    SELECT chl.horas_autoestudio_diarias
    INTO v_horas_autoestudio_diarias
    FROM CONFIG_HORAS_LABORALES chl
    WHERE chl.unidad_organizacional_id = v_unidad_id
        AND chl.activo = 'S'
        AND chl.aplica_autoestudio = 'S';

    -- Si no hay configuración, no aplica autoestudio
    IF v_horas_autoestudio_diarias IS NULL THEN
        RETURN 0;
    END IF;

    -- Calcular días laborales en el trimestre para el empleado (considerando ausencias que afectan estudio)
    SELECT COUNT(*)
    INTO v_dias_laborales
    FROM CALENDARIO_LABORAL c
    WHERE c.anio_id = p_anio_id
        AND c.periodo_id = p_periodo_id
        AND c.es_laboral = 'S'
        AND NOT EXISTS (
            SELECT 1
            FROM AUSENCIA a
            WHERE a.empleado_id = p_empleado_id
                AND a.tipo_ausencia_id IN (SELECT tipo_ausencia_id FROM TIPO_AUSENCIA WHERE afecta_estudio = 'S')
                AND c.fecha BETWEEN a.fecha_inicio AND a.fecha_fin
        );

    RETURN v_dias_laborales * v_horas_autoestudio_diarias;
END;
/

-- También podemos crear un procedimiento para actualizar el saldo de vacaciones acumuladas, que se puede ejecutar periódicamente o con un trigger.
-- Pero por ahora, lo dejamos como una función que calcula el saldo al momento.

-- Podemos crear un paquete para manejar todas las funciones y procedimientos relacionados con el cálculo de vacaciones, autoestudio, etc.

-- Dado que el sistema es complejo, es posible que necesitemos más tablas, vistas, y procedimientos. Pero esto es un buen punto de partida.

-- También necesitaremos tablas para la auditoría de cambios, pero por ahora nos enfocamos en el modelo principal.

-- Finalmente, es importante tener en cuenta que en Oracle APEX, podemos utilizar estas tablas para construir la aplicación.

-- Nota: Este script es un borrador inicial y puede requerir ajustes según las necesidades específicas.





*************************

chat gpt:

-- ============================================
-- Esquema: HR_TRAINING (ejemplo). Ajusta el OWNER si hace falta.
-- Este script crea tablas, índices, secuencias, vistas y paquetes base.
-- Ejecutar como usuario con privilegios para crear objetos.
-- ============================================

-- -----------------------
-- SECUENCIAS
-- -----------------------
CREATE SEQUENCE seq_employees START WITH 1000 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE SEQUENCE seq_projects  START WITH 10000 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE SEQUENCE seq_course    START WITH 5000 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE SEQUENCE seq_vac_req   START WITH 20000 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE SEQUENCE seq_study_plan START WITH 30000 INCREMENT BY 1 NOCACHE NOCYCLE;
CREATE SEQUENCE seq_weekly_report START WITH 40000 INCREMENT BY 1 NOCACHE NOCYCLE;

-- -----------------------
-- TABLAS DE CATÁLOGOS
-- -----------------------
CREATE TABLE cfg_periods (
  period_id     NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  code          VARCHAR2(10) NOT NULL, -- I, II, III, IV
  description   VARCHAR2(50) NOT NULL,
  created_at    DATE DEFAULT SYSDATE,
  created_by    VARCHAR2(100)
);

CREATE UNIQUE INDEX ux_cfg_periods_code ON cfg_periods(code);

CREATE TABLE cfg_years (
  year_id       NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  yr            NUMBER(4) NOT NULL UNIQUE,
  created_at    DATE DEFAULT SYSDATE,
  created_by    VARCHAR2(100)
);

CREATE TABLE cfg_competencies (
  competency_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  name          VARCHAR2(200) NOT NULL,
  description   VARCHAR2(1000),
  active_flag   CHAR(1) DEFAULT 'Y' CHECK (active_flag IN ('Y','N')),
  created_at    DATE DEFAULT SYSDATE
);

CREATE TABLE cfg_issuers (
  issuer_id     NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  name          VARCHAR2(200) NOT NULL,
  website       VARCHAR2(400),
  notes         VARCHAR2(1000),
  active_flag   CHAR(1) DEFAULT 'Y'
);

CREATE TABLE cfg_course_states (
  state_id      NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  code          VARCHAR2(30) UNIQUE,
  description   VARCHAR2(100)
);

-- Cursos / certificaciones catálogo
CREATE TABLE cfg_courses (
  course_id     NUMBER PRIMARY KEY,
  code          VARCHAR2(100) UNIQUE, -- tal vez código externo
  title         VARCHAR2(400) NOT NULL,
  issuer_id     NUMBER REFERENCES cfg_issuers(issuer_id),
  type          VARCHAR2(50), -- Capacitación, Certificación, Curso
  planned_hours NUMBER(8,2), -- horas planeadas (decimal)
  cost          NUMBER(12,2) DEFAULT 0,
  active_flag   CHAR(1) DEFAULT 'Y',
  created_at    DATE DEFAULT SYSDATE
);

-- Projects catalog (codigo externo que se debe respetar)
CREATE TABLE cfg_projects (
  project_id    NUMBER PRIMARY KEY,
  external_code VARCHAR2(100) UNIQUE NOT NULL,
  name          VARCHAR2(400) NOT NULL,
  description   VARCHAR2(1000),
  active_flag   CHAR(1) DEFAULT 'Y'
);

-- Estados de proyecto (catalogo simple)
CREATE TABLE cfg_project_status (
  status_id     NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  code          VARCHAR2(50) UNIQUE,
  description   VARCHAR2(200)
);

-- -----------------------
-- ESTRUCTURA ORGANIZACIONAL
-- -----------------------
CREATE TABLE org_gerencias (
  gerencia_id   NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  code          VARCHAR2(50) UNIQUE,
  name          VARCHAR2(200) NOT NULL,
  parent_id     NUMBER, -- para jerarquías superiores (opcional)
  notes         VARCHAR2(1000)
);

CREATE TABLE org_vice_gerencias (
  vice_id       NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  gerencia_id   NUMBER NOT NULL REFERENCES org_gerencias(gerencia_id),
  name          VARCHAR2(200) NOT NULL,
  code          VARCHAR2(50),
  notes         VARCHAR2(1000)
);

-- Tabla básica de cargos
CREATE TABLE org_positions (
  position_id   NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  title         VARCHAR2(200) NOT NULL,
  level         VARCHAR2(50)
);

-- Empleados (catalogo empleados)
CREATE TABLE employees (
  employee_id   NUMBER PRIMARY KEY,
  code          VARCHAR2(50) UNIQUE,
  first_name    VARCHAR2(200),
  last_name     VARCHAR2(200),
  full_name     VARCHAR2(400),
  gerencia_id   NUMBER REFERENCES org_gerencias(gerencia_id),
  vice_id       NUMBER REFERENCES org_vice_gerencias(vice_id),
  position_id   NUMBER REFERENCES org_positions(position_id),
  manager_id    NUMBER, -- referencia al jefe directo; FK circular opcional (chequeo por app)
  hire_date     DATE,
  email         VARCHAR2(200),
  work_hours_per_day NUMBER(4,2) DEFAULT 9, -- valor por empleado si aplica override
  active_flag   CHAR(1) DEFAULT 'Y' CHECK (active_flag IN ('Y','N')),
  created_at    DATE DEFAULT SYSDATE
);

-- Constraints FK circular: se deja sin FK para facilitar carga masiva. Se puede agregar constraint luego.
ALTER TABLE employees ADD CONSTRAINT fk_emp_vice FOREIGN KEY (vice_id) REFERENCES org_vice_gerencias(vice_id);

-- Tabla que define roles en la aplicacion (para APEX/seguridad)
CREATE TABLE app_roles (
  role_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  code    VARCHAR2(100) UNIQUE,
  description VARCHAR2(200)
);

CREATE TABLE employee_role (
  employee_id NUMBER REFERENCES employees(employee_id),
  role_id     NUMBER REFERENCES app_roles(role_id),
  assigned_at DATE DEFAULT SYSDATE,
  PRIMARY KEY (employee_id, role_id)
);

-- -----------------------
-- HORARIOS Y CONFIGURACIONES POR GERENCIA
-- -----------------------
-- Permite definir si trabajan sabados, horas por dia, etc.
CREATE TABLE org_work_schedule (
  schedule_id  NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  gerencia_id  NUMBER REFERENCES org_gerencias(gerencia_id),
  works_saturday CHAR(1) DEFAULT 'N' CHECK (works_saturday IN ('Y','N')),
  hours_per_day NUMBER(5,2) DEFAULT 9, -- configurable
  created_at    DATE DEFAULT SYSDATE
);

-- -----------------------
-- CALENDARIO Y FERIADOS
-- -----------------------
CREATE TABLE calendar_holidays (
  holiday_id    NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  holiday_date  DATE NOT NULL,
  description   VARCHAR2(400),
  half_day_flag CHAR(1) DEFAULT 'N' CHECK (half_day_flag IN ('Y','N')), -- si es 0.5 día
  created_at    DATE DEFAULT SYSDATE
);

CREATE UNIQUE INDEX ux_holiday_date ON calendar_holidays(holiday_date);

-- -----------------------
-- VACACIONES Y PERMISOS
-- -----------------------
CREATE TABLE vacation_requests (
  vac_req_id    NUMBER PRIMARY KEY,
  employee_id   NUMBER NOT NULL REFERENCES employees(employee_id),
  year_id       NUMBER REFERENCES cfg_years(year_id),
  period_id     NUMBER REFERENCES cfg_periods(period_id),
  start_date    DATE NOT NULL,
  end_date      DATE NOT NULL,
  total_days    NUMBER(8,2), -- calculado (incluye fraccion 0.5 etc)
  total_hours   NUMBER(10,2),
  type_code     VARCHAR2(50), -- VACATION, PERMISSION, SUBSIDY, etc
  status        VARCHAR2(50) DEFAULT 'PENDING',
  created_at    DATE DEFAULT SYSDATE,
  created_by    VARCHAR2(100),
  notes         VARCHAR2(1000)
);

-- Detalle por día en caso que se necesite trazabilidad
CREATE TABLE vacation_days (
  vac_day_id    NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  vac_req_id    NUMBER REFERENCES vacation_requests(vac_req_id),
  day_date      DATE NOT NULL,
  day_fraction  NUMBER(4,2) DEFAULT 1, -- 1 = full day, 0.5 = medio dia, 0.138... = 1 hora / 9 etc
  is_workday    CHAR(1) DEFAULT 'Y' CHECK (is_workday IN ('Y','N')),
  created_at    DATE DEFAULT SYSDATE
);

-- -----------------------
-- AUTOESTUDIO / CAPACITACIÓN
-- -----------------------
-- Plan de estudio por trimestre
CREATE TABLE study_plans (
  plan_id       NUMBER PRIMARY KEY,
  employee_id   NUMBER NOT NULL REFERENCES employees(employee_id),
  year_id       NUMBER REFERENCES cfg_years(year_id),
  period_id     NUMBER REFERENCES cfg_periods(period_id),
  course_id     NUMBER REFERENCES cfg_courses(course_id),
  competency_id NUMBER REFERENCES cfg_competencies(competency_id),
  planned_hours NUMBER(8,2) DEFAULT 0,
  planned_start_date DATE,
  planned_end_date   DATE,
  status        VARCHAR2(50) DEFAULT 'PENDING',
  created_at    DATE DEFAULT SYSDATE
);

-- Registro de horas cursadas (logs)
CREATE TABLE study_logs (
  log_id        NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  plan_id       NUMBER REFERENCES study_plans(plan_id),
  employee_id   NUMBER REFERENCES employees(employee_id),
  log_date      DATE DEFAULT SYSDATE,
  hours         NUMBER(8,2) DEFAULT 0,
  comment       VARCHAR2(1000),
  created_at    DATE DEFAULT SYSDATE
);

-- Tabla resumen/cache para avance por plan (se puede mantener con jobs o triggers)
CREATE TABLE study_progress_cache (
  plan_id       NUMBER PRIMARY KEY,
  total_hours_logged NUMBER(10,2),
  percent_complete NUMBER(5,2),
  last_update   DATE
);

-- -----------------------
-- COMPETENCIAS POR EMPLEADO
-- -----------------------
CREATE TABLE employee_competencies (
  emp_comp_id   NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  employee_id   NUMBER REFERENCES employees(employee_id),
  competency_id NUMBER REFERENCES cfg_competencies(competency_id),
  desired_level NUMBER(3) CHECK (desired_level BETWEEN 1 AND 10),
  current_level NUMBER(3) CHECK (current_level BETWEEN 1 AND 10),
  gap_level     NUMBER GENERATED ALWAYS AS (desired_level - current_level) VIRTUAL,
  updated_at    DATE DEFAULT SYSDATE
);

-- -----------------------
-- INFORME SEMANAL (por proyecto)
-- -----------------------
CREATE TABLE weekly_reports (
  report_id     NUMBER PRIMARY KEY,
  project_id    NUMBER REFERENCES cfg_projects(project_id),
  employee_id   NUMBER REFERENCES employees(employee_id),
  week_start    DATE NOT NULL, -- fecha de inicio de la semana
  week_end      DATE NOT NULL,
  percent       NUMBER(5,2) DEFAULT 0,
  summary       VARCHAR2(4000), -- texto del informe semanal
  created_at    DATE DEFAULT SYSDATE,
  UNIQUE (project_id, employee_id, week_start)
);

-- -----------------------
-- CAPACITACIÓN: ENROLLMENTS Y ESTADOS
-- -----------------------
CREATE TABLE training_enrollments (
  enroll_id     NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  plan_id       NUMBER REFERENCES study_plans(plan_id),
  employee_id   NUMBER REFERENCES employees(employee_id),
  course_id     NUMBER REFERENCES cfg_courses(course_id),
  state_id      NUMBER REFERENCES cfg_course_states(state_id),
  hours_logged  NUMBER(10,2) DEFAULT 0,
  created_at    DATE DEFAULT SYSDATE
);

-- -----------------------
-- AUDIT / SOFT DELETE
-- -----------------------
-- Para cada tabla crítica podemos tener columnas audit. Ejemplo es employees ya tiene created_at.
-- Crearemos tabla de audit genérica.
CREATE TABLE audit_log (
  audit_id      NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
  obj_name      VARCHAR2(100),
  obj_pk        VARCHAR2(200),
  action        VARCHAR2(20),
  action_by     VARCHAR2(200),
  action_at     DATE DEFAULT SYSDATE,
  details       CLOB
);

-- -----------------------
-- ÍNDICES ADICIONALES (BÚSQUEDA RÁPIDA)
-- -----------------------
CREATE INDEX ix_employees_gerencia ON employees(gerencia_id);
CREATE INDEX ix_employees_vice ON employees(vice_id);
CREATE INDEX ix_studyplan_employee ON study_plans(employee_id);
CREATE INDEX ix_vacation_employee ON vacation_requests(employee_id);
CREATE INDEX ix_weekly_project_employee ON weekly_reports(project_id, employee_id);

-- -----------------------
-- VISTAS ÚTILES
-- -----------------------
-- Vista: vista simple de empleado con jerarquía
CREATE OR REPLACE VIEW vw_employees_full AS
SELECT e.employee_id, e.code, e.full_name, e.email, e.hire_date,
       g.gerencia_id, g.name gerencia_name,
       v.vice_id, v.name vice_name,
       p.position_id, p.title position_title
FROM employees e
LEFT JOIN org_gerencias g ON e.gerencia_id = g.gerencia_id
LEFT JOIN org_vice_gerencias v ON e.vice_id = v.vice_id
LEFT JOIN org_positions p ON e.position_id = p.position_id;

-- Vista: acumulado de horas plan y cursadas por plan
CREATE OR REPLACE VIEW vw_study_progress AS
SELECT sp.plan_id, sp.employee_id, sp.course_id, sp.planned_hours,
       NVL((SELECT SUM(hours) FROM study_logs sl WHERE sl.plan_id = sp.plan_id),0) total_logged,
       CASE WHEN sp.planned_hours > 0 THEN
            ROUND(NVL((SELECT SUM(hours) FROM study_logs sl WHERE sl.plan_id = sp.plan_id),0) / sp.planned_hours * 100,2)
       ELSE NULL END percent_complete
FROM study_plans sp;

-- Vista: reporte de vacaciones por empleado por año
CREATE OR REPLACE VIEW vw_vacation_summary AS
SELECT e.employee_id, e.full_name, cy.yr as year,
       NVL(SUM(vr.total_days),0) total_days_requested,
       NVL(SUM(vr.total_hours),0) total_hours_requested
FROM employees e
LEFT JOIN vacation_requests vr ON e.employee_id = vr.employee_id
LEFT JOIN cfg_years cy ON vr.year_id = cy.year_id
GROUP BY e.employee_id, e.full_name, cy.yr;

-- -----------------------
-- FUNCIONES Y PROCEDIMIENTOS UTILES (PL/SQL)
-- -----------------------

-- 1) Función que calcula días laborales entre dos fechas considerando feriados y si la gerencia trabaja sábados
CREATE OR REPLACE FUNCTION fn_workdays_between (
  p_start_date  IN DATE,
  p_end_date    IN DATE,
  p_gerencia_id IN NUMBER
) RETURN NUMBER IS
  v_count NUMBER := 0;
  v_date  DATE;
  v_works_sat CHAR(1);
BEGIN
  IF p_start_date IS NULL OR p_end_date IS NULL THEN
    RETURN NULL;
  END IF;
  -- obtener configuración
  SELECT NVL(works_saturday,'N') INTO v_works_sat
  FROM org_work_schedule WHERE gerencia_id = p_gerencia_id
  AND ROWNUM = 1;

  v_date := TRUNC(p_start_date);
  WHILE v_date <= TRUNC(p_end_date) LOOP
    -- Si es feriado?
    IF EXISTS (SELECT 1 FROM calendar_holidays ch WHERE ch.holiday_date = v_date) THEN
      NULL;
    ELSE
      -- día de semana (1=domingo, 7=sábado)
      IF TO_CHAR(v_date,'DY','NLS_DATE_LANGUAGE=SPANISH') IN ('SÁB','SAB','SUN') THEN
        -- comprobar sábado
        IF v_works_sat = 'Y' THEN
          IF TO_CHAR(v_date,'DY','NLS_DATE_LANGUAGE=SPANISH') IN ('SÁB','SAB') THEN
            v_count := v_count + 1;
          END IF;
        END IF;
        -- domingos siempre no laborables
      ELSE
        -- día normal de semana
        IF NOT (TO_CHAR(v_date,'D') IN ('1')) THEN -- alternativa robusta: usar TO_CHAR(...,'DY') logic arriba
          v_count := v_count + 1;
        ELSE
          v_count := v_count + 1;
        END IF;
      END IF;
    END IF;
    v_date := v_date + 1;
  END LOOP;
  RETURN v_count;
EXCEPTION WHEN NO_DATA_FOUND THEN
  -- si no hay configuración, asumimos no sábados
  v_date := TRUNC(p_start_date);
  v_count := 0;
  WHILE v_date <= TRUNC(p_end_date) LOOP
    IF NOT EXISTS (SELECT 1 FROM calendar_holidays ch WHERE ch.holiday_date = v_date) AND TO_CHAR(v_date,'D') NOT IN ('1') THEN
      v_count := v_count + 1;
    END IF;
    v_date := v_date + 1;
  END LOOP;
  RETURN v_count;
END;
/

-- 2) Función que calcula horas laborales totales entre fechas para una gerencia (usa fn_workdays_between)
CREATE OR REPLACE FUNCTION fn_workhours_between (
  p_start_date  IN DATE,
  p_end_date    IN DATE,
  p_gerencia_id IN NUMBER
) RETURN NUMBER IS
  v_days NUMBER;
  v_hours_per_day NUMBER;
BEGIN
  v_days := fn_workdays_between(p_start_date, p_end_date, p_gerencia_id);
  SELECT NVL(hours_per_day,9) INTO v_hours_per_day
  FROM org_work_schedule WHERE gerencia_id = p_gerencia_id AND ROWNUM = 1;
  RETURN v_days * v_hours_per_day;
EXCEPTION WHEN NO_DATA_FOUND THEN
  RETURN v_days * 9; -- default
END;
/

-- 3) Calcular acumulación de vacaciones por período (ej: 2.5 días por mes)
CREATE OR REPLACE FUNCTION fn_vacation_accrual_by_months (
  p_employee_id IN NUMBER,
  p_months      IN NUMBER
) RETURN NUMBER IS
  v_days NUMBER;
BEGIN
  -- política general 2.5 días por mes (configurable si deseas almacenar por org)
  v_days := 2.5 * p_months;
  RETURN v_days;
END;
/

-- 4) Calcular horas de autoestudio por trimestre para un empleado:
-- 1 hora por día laborado (configurable si gerencia no aplica autoestudio)
CREATE OR REPLACE FUNCTION fn_study_hours_quarter (
  p_employee_id IN NUMBER,
  p_year_id     IN NUMBER,
  p_period_id   IN NUMBER
) RETURN NUMBER IS
  v_start_date DATE;
  v_end_date DATE;
  v_gerencia_id NUMBER;
  v_workdays NUMBER;
  v_hours_per_day NUMBER;
  v_hours NUMBER;
BEGIN
  -- Determinar rango de fechas por period (ejemplo simple: period 1 = ene-mar, etc).
  -- Aquí asumimos que la app APEX establecerá las fechas; de momento devolvemos aproximado:
  SELECT e.gerencia_id INTO v_gerencia_id FROM employees e WHERE e.employee_id = p_employee_id;
  -- Para cálculo exacto se necesita tabla period_dates; proponemos usarla. 
  -- Si no existe, la función retorna número de dias laborales en el trimestre multiplicado por 1 hora/día.
  -- Ejemplo: buscar min/max fechas de study_plans o fallback
  SELECT MIN(pl.planned_start_date), MAX(pl.planned_end_date) INTO v_start_date, v_end_date
  FROM study_plans pl WHERE pl.employee_id = p_employee_id AND pl.year_id = p_year_id AND pl.period_id = p_period_id;

  IF v_start_date IS NULL OR v_end_date IS NULL THEN
    RETURN 0;
  END IF;
  v_workdays := fn_workdays_between(v_start_date, v_end_date, v_gerencia_id);
  -- 1 hora por día
  v_hours := v_workdays * 1;
  RETURN v_hours;
EXCEPTION WHEN NO_DATA_FOUND THEN
  RETURN 0;
END;
/

-- -----------------------
-- PAQUETE ADMIN (procedimientos comunes)
-- -----------------------
CREATE OR REPLACE PACKAGE pkg_admin AS
  PROCEDURE create_course(p_code VARCHAR2, p_title VARCHAR2, p_issuer_id NUMBER, p_planned_hours NUMBER, p_cost NUMBER);
  PROCEDURE add_holiday(p_date DATE, p_description VARCHAR2, p_half_day CHAR := 'N');
  PROCEDURE recalc_study_progress(p_plan_id NUMBER);
END pkg_admin;
/

CREATE OR REPLACE PACKAGE BODY pkg_admin AS

  PROCEDURE create_course(p_code VARCHAR2, p_title VARCHAR2, p_issuer_id NUMBER, p_planned_hours NUMBER, p_cost NUMBER) IS
    v_id NUMBER;
  BEGIN
    v_id := seq_course.NEXTVAL;
    INSERT INTO cfg_courses(course_id, code, title, issuer_id, planned_hours, cost, created_at)
    VALUES (v_id, p_code, p_title, p_issuer_id, p_planned_hours, p_cost, SYSDATE);
    INSERT INTO audit_log(obj_name, obj_pk, action, action_by, details)
    VALUES('cfg_courses', v_id, 'INSERT', USER, 'Curso creado via pkg_admin');
  END create_course;

  PROCEDURE add_holiday(p_date DATE, p_description VARCHAR2, p_half_day CHAR := 'N') IS
  BEGIN
    INSERT INTO calendar_holidays (holiday_date, description, half_day_flag, created_at)
    VALUES (TRUNC(p_date), p_description, NVL(p_half_day,'N'), SYSDATE);
    INSERT INTO audit_log(obj_name, obj_pk, action, action_by, details)
    VALUES('calendar_holidays', TO_CHAR(TRUNC(p_date),'YYYYMMDD'), 'INSERT', USER, 'Feriado agregado');
  EXCEPTION WHEN DUP_VAL_ON_INDEX THEN
    -- Actualizar si ya existe
    UPDATE calendar_holidays SET description = p_description, half_day_flag = p_half_day WHERE holiday_date = TRUNC(p_date);
  END add_holiday;

  PROCEDURE recalc_study_progress(p_plan_id NUMBER) IS
    v_total NUMBER;
    v_planned NUMBER;
    v_percent NUMBER;
  BEGIN
    SELECT NVL(SUM(hours),0) INTO v_total FROM study_logs WHERE plan_id = p_plan_id;
    SELECT planned_hours INTO v_planned FROM study_plans WHERE plan_id = p_plan_id;
    IF v_planned > 0 THEN
      v_percent := ROUND(v_total / v_planned * 100, 2);
    ELSE
      v_percent := NULL;
    END IF;

    MERGE INTO study_progress_cache c USING (SELECT p_plan_id plan_id FROM DUAL) src
    ON (c.plan_id = src.plan_id)
    WHEN MATCHED THEN UPDATE SET total_hours_logged = v_total, percent_complete = v_percent, last_update = SYSDATE
    WHEN NOT MATCHED THEN INSERT (plan_id, total_hours_logged, percent_complete, last_update)
         VALUES (p_plan_id, v_total, v_percent, SYSDATE);

    INSERT INTO audit_log(obj_name, obj_pk, action, action_by, details)
    VALUES('study_progress_cache', p_plan_id, 'RECALC', USER, 'Recalculado por pkg_admin.recalc_study_progress');

  END recalc_study_progress;

END pkg_admin;
/

-- -----------------------
-- TRIGGERS EJEMPLO (AUDITORÍA BÁSICA)
-- -----------------------
CREATE OR REPLACE TRIGGER trg_employees_ai
AFTER INSERT ON employees
FOR EACH ROW
BEGIN
  INSERT INTO audit_log(obj_name, obj_pk, action, action_by, details)
  VALUES('employees', :NEW.employee_id, 'INSERT', USER, 'Empleado creado');
END;
/

-- -----------------------
-- VISTAS Y PROCEDIMIENTOS DE REPORTES
-- -----------------------
-- Vista: horas planeadas vs horas cursadas por empleado y trimestre
CREATE OR REPLACE VIEW vw_training_quarter_summary AS
SELECT sp.employee_id, cy.yr, cp.code period_code, sp.period_id, sp.plan_id,
       sp.planned_hours,
       NVL((SELECT SUM(sl.hours) FROM study_logs sl WHERE sl.plan_id = sp.plan_id),0) hours_logged,
       CASE WHEN sp.planned_hours > 0 THEN ROUND(NVL((SELECT SUM(sl.hours) FROM study_logs sl WHERE sl.plan_id = sp.plan_id),0) / sp.planned_hours * 100,2) ELSE NULL END pct_complete
FROM study_plans sp
JOIN cfg_periods cp ON sp.period_id = cp.period_id
JOIN cfg_years cy ON sp.year_id = cy.year_id;

-- -----------------------
-- REGLAS Y CHECKS ADICIONALES
-- -----------------------
-- Limitar acumulación de vacaciones (ejemplo view para notificación)
CREATE OR REPLACE VIEW vw_employees_vacation_balance AS
SELECT e.employee_id, e.full_name,
       NVL(SUM(vr.total_days),0) AS total_days_taken
FROM employees e
LEFT JOIN vacation_requests vr ON e.employee_id = vr.employee_id AND vr.status = 'APPROVED'
GROUP BY e.employee_id, e.full_name;

-- Puedes construir una vista adicional que compare el derecho acumulado (fn_vacation_accrual_by_months) con total_days_taken.

-- ============================================
-- FIN DEL SCRIPT BASE
-- ============================================



Prompt:

Existe un libro de excel en mi trabajo donde llevamos muchos registros correspondientes a las horas de estudio de los colaboradores para certificarse de manera diaria, tambien lleva el control de vacaciones, el catalogo de personal, y multiples catalogos que alimentan cada una de las hojas, pero ocurre que ha crecido grandemente la empresa, y al estar en linea en el onedrive han ocurrido ediciones involuntarias e incluso corrupción de libro teniendo que hacer rollback de ediciones perdiendo información importante, queremos dar un paso mas allá siendo la gerencia de tecnologia quiero proponer un sistema hecho en oracle apex para llevar estas gestiones, creando una base de datos robusta en oracle con plsql, para ello te voy a dar el listado de requerimientos a tener en cuenta para que generes el script de la base de datos, con sus tablas, tipos, indices, vistas, paquetes, funciones, etc, en base a las necesidades, entidades identificadas, etc. necesitamos normalizar, eliminar datos duplicados, etc, el sistema debe tener un modulo administrativo para agregar catalogos y autogestionarlos, es decir si alguien nuevo llevará un nuevo curso el pueda agregarlo, pero existirá otra administración que estara reservada para los jefes o coordinadores donde podrá administrar su equipo, los jefes pueden tener jerarquias, es decir, en TI existen vice gerencias: Base de datos, Redes, Soporte, Desarrollo Oracle, Desarrollo Onpremise, Desarrollo de Bots, cada una de estas vice gerencias tienen varios coordinadores especialmente las de desarrollo, estos solamente podrán ver el equipo a cargo, sin embargo el gerente y vice gerente de TI podrá  ver todo lo que corresponde a TI, asi sucesivamente, con esa logica debería gestionar la Gerencia de contabilidad, Canales digitales, etc, y habrá una jerarquia superior: Gerencia General y Capital Humano que podrá revisar todas las gerencias del banco, por lo que el sistema tiene que tener en cuenta los filtros por gerencias, vice gerencias, coordinadores y colaboradores, pueden haber vice gerencias que no tengan coordinadores sino el gerente coordina directamente el personal por que son gerencias pequeñas, generar reportes, visualizar la información registrada y tomar decisiones.

A continuación te detallo cada una de las hojas de excel y su contenido para que empieces armar el script de base de datos para luego yo armar el sistema en Oracle Apex,


Hoja Catalogos:
En esta hoja se administran los catalogos del libro de excel:
	- Periodo: catalogo fijo de trimestre, en la empresa se tabaja trimestral, por lo que este catalogo no varía, I Trimestre, II Trimestre, III Trimestre y IV Trimestre
	- Año: El año en curso, este solo el administrador del sistema lo puede agregar, ejemplo: 2023, 2024 y 2025
	- Competencias: se almacenan las competencias que los colaboradores adquieren en los cursos, ejemplo: PL/SQL, GIT, Oracle SOA, Fabric, JAVA, SQL, etc.
	- Curso/ Certificación: catalogo de los cursos que estan llevando o llevaran para el autoestudio, antes de iniciar un trimestre los colaboradores registran el curso que llevaran, se llena en este catalogo cada curso puede tener los siguientes campos: 
	- Emitido por: Es la empresa que emite el certificado o curso, ejemplo: Microsoft, Youtube, Udemy, Tecnasa, AuraQuantic, etc.
	- Empleados: catalogo de colaboradores contienen los siguientes campos: Codigo, Nombre, Gerencia, Cargo,Fecha de ingreso
	- Estado de curso: Finalizado, Pendiente, En curso.
	Proyecto: Este es el listado  de proyectos que llevan los colaboradores para desarrollo en cada trimestre, este se alimenta luego unas hojas que se detallaran mas adelante.Columna nombre y codigo de proyecto, este codigo lo genera un sistema externo, se debe respetar.
	
	
Hoja Vacaciones: Esta hoja se llena anualmente, sin embargo puede ir ajustandose en base a las necesidades de los colaboradores o imprevistos, los colaboradores (catalogo empleados) planificamos los dias de vacaciones que vamos a tomar en el año (catalogo de año) por cada trimestre (catalogo trimestre), aqui se debe tener en cuenta varias reglas, por ejemplo los feriados, permisos, vacaciones, fines de semana extendidos de vacaciones: estos consisten en tomar 1.25 dias el viernes y 1.25 dias el lunes en concepto de vacaciones, sabados y domingos no se trabaja, hay dias que son feriados de ley otros que se deben contar como 0.5 dias, el colaborador puede pedir desde 1 hora, hasta las 9 horas del día, esta se debe calcular en base a las horas del día, si se toma medio dia entonces es 0.5 dias, por ley se tiene derecho a vacaciones, por cada dia laborado, el sistema debe llevar un contador de dias laborales, actualmente se lleva en otra hoja llamada Calendario, donde se muestra literalmente un calendario con cada uno de los meses, se cuentan los días por semana laborales, ejemplo para enero 2025
Primera semana: 2 días, dado a que el 1ero es feriado, no cuenta, solo el jueves 2 y viernes 3,
Segunda semana: 5 días, Tercera semana: 5 días, Cuarta Semana: 5 días, en total en el mes de enero se debe laborar: 22 días restando sabados y domingos,

Luego en febrero: 1er semana: 0 dias dado a que es sabado 1ero de febrero, 2da semana: 5 dias, 3er semana: 5 días, 4ta semana: 5 días, 5ta semana 0, ten en cuenta que hay meses que pueden tener hasta 6 semanas, total: 20 días, 

Asi sucesivamente, entonces da un total de 22 + 20 + 21 (marzo) = 63 dias laborales para el 1er trimestre del año 2025

Para el 2do trimestre, hay dias feriado, por ejemplo: semana santa: jueves 17 y 18 de abril,  este da un total de 20 dias, luego mayo 20 excluyendo feriados: 1ero por ser dia del trabajador, 30 de mayo por ser el dia de la madre, creo que ya la idea se entiende, en total suman 61 dias laborales para el segundo trimestre 2025, 

Por cada trimestre se deben calcular la cantidad de horas, es decir si en el 1er trimestre se harán 63 dias esto se debe multiplicar por 9 horas  laborales (nota, hay gerencias que trabajan 8 horas pero trabajan los sabados, tener en cuenta que esto debe ser configurable), es decir 567 horas, pero hay que tener en cuenta que por cada mes, se tiene derecho a 2.5 dias de vacaciones, por lo tanto se deben restar, con la formula: 2.5 * 3 (el 3 representa a un trimestre), resultando: 559.5


Finalmente se tiene la suma total del año sumando todos los dias laborales del año, horas laborales 251 y horas laborales 2259, restando sus 30 días de vacaciones (2.5 dias * 12 meses)
es decir: 2229 realmente la que cada colaborador debe trabajar, 
 
Todo esto con el objetivo de calcular las vacaciones correctamente y las horas correspondientes al auto estudio, volvamos a la hoja: Vacaciones, dado a la explicación anterior en la hoja de vacaciones se muestra de la siguiente manera:



Primera columna: Nombre colaborador, los trimestres del año (2025 por ejemplo) combinados por cada 3 meses, en la siguiente fila los meses Enero esta celda esta combinada y finalmente la fila que contiene cada uno de los días del mes en el encabezado indica el día de la semana (con el fin de excluir en las formulas los sabados y domingos por el nombre), en cada uno de las celdas correspondientes a los colaboradores se definenen dos filas por colaborador: la primera es solamente un contador, esta indica la cantidad de horas acumuladas en el trimestre, esta se debe tomar en cuenta en base al la fecha de ingreso del colaborador, si inicia desde enero no hay problemas, pero si inicia el 22 febrero se debe iniciar el contador de dias de vacaciones a partir de esta fecha, el objetivo de esta hoja es marcar los dias de vacaciones, feriados, subsidios, permisos, etc, por colaborador, con el fin de determinar la cantidad de horas de autoestudio que debe tener un colaborador (el tema de auto estudio va a depender de la gerencia, no aplica a todas las gerencias esto se debe configurar al cuando se creen los grupos de las gerencias), un colaborador debe registrar 1 hora de auto estudio por cada dia laborado, si se pide 0.5 dias de vacaciones, permiso, feriado, subsidios, etc, el contador de dia de hora de autoestudio para ese dia no cuenta, se omite, tambien esta hoja sirve  para determinar la cantidad de dias de vacaciones acumuladas y gozadas por mes, trimestre o año, los colaboradores no deben tener mas de 10 dias de vacaciones acumuladas, esto se debe calcular para enviar notificaciones a jefes y colaboradores via correo, teniendo en cuenta los dias de vacaciones que se acumularan por trimestre, es decir si lleva acumulandose incluso del año anterior, esto se va acumulando, no se debe perder independientemente si se ha creado un nuevo año 2026 por ejemplo, si al finalizar el año 2025 quedaron 5 dias de vacaciones, estas siguen sumando en el año 2026

Hoja Competencias, indica las habilidades que cada colaborar tiene: esta tiene el cargo, nombre de colaborador, el catalogo de competencias, el nivel deseado valor entero del 1-10, el nivel de conocimiento actual: 1-10 y GAP 

Hoja informe semanal, esta es una hoja que se filtra por trimestre, tiene el codigo del proyecto, nombre, estado (analisis, desarrollo, cancelado, soporte, finalizado, suspendido), porcentaje (este se debe ir registrando el proceso global del proyecto), el usuario debe registrar semanalmente una descripción a modo de resumen ejecutivo lo realizado a cada a cada proyecto que esté en analisis, desarrollo, soporte, de manera que el jefe, coordinador, gerente a cargo pueda visualizar por colaborador el porcentaje del proyecto en cada semana, este porcentaje se va sumando, este resumen se registra actualmente en una sola celda por proyecto, cada colaborador ingresa su porcentaje actualizado del proyecto, esto con el objetivo de ir viendo con el tiempo en cada semana el avance del proyecto, y los comentarios de cada uno, ejemplo: Nombre 1: comentarios 1, Nombre 2: comentarios 2, Nombre 3: comentarios 
3 esto lo deberiamos mejorar y normalizarlo,

Finalmente la hoja de capacitación: Se debe filtrar por año y trimestre, las columnas son:
Año, Periodo (trimestre), Costo (si aplica) o 0 = dejar gratis, Catalogo competencia, Catalogo curso /Certificación, Catalogo Nombre empleado, Catalogo cargo, Avance anterior (porcentaje), Avance del mes (porcentaje), Avance actual (porcentaje), creo que esto deberia calcularse automaticamente en base a la cantidad de horas del curso y las cantidad de horas cursadas, Catalogo de Emitido por, Catalogo de estado de curso, Fecha de inicio tipo date Null, fecha fin tipo date null,  Columna nivel de Conocimientos en el tema: numero 1-10, Nivel de conocimiento deseado: numero del 1-10, Nivel conocimiento inicial, Nivel de conocimiento final, ambos numerico del 1-10, tipo: Catalogo de tipo de curso: Capacitación, Certificación, Curso, Tiempo de curso: tipo decimal, Tiemplo plan: tipo decimal, Tiempo cursado tipo decimal.


Luego existe una hoja con una tabla dinamica que toma los colaboradores, y suma por empleado las horas planificadas de estudios, y en otra columna suma todos los cursos del trimestre y sumas las horas cursadas, el porcentaje de avance, la cantidad de dias laborales menos la cantidad de dias de vacaciones, menos los dias que tienen 0.5 dias de vacaciones o feriados, fin de semana, para asi determinar la cantidad real de horas ya sin vacaciones o dias sin laborar.

